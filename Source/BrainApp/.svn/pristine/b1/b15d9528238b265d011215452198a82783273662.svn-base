# Import sys, os modules in Python.
# These are needed to run the GUI and 
# also to handle directory and other os related functions
import sys, os
from ctypes import *
from winpcapy import *
import string
import socket as sk
import platform
import copy
from xml.etree import ElementTree
from time import sleep
from collections import defaultdict
import threading
import subprocess
import time

# Import the modules QtCore (for low level Qt functions)
# QtGui (for visual/GUI related Qt functions)
from PyQt4 import QtCore, QtGui, Qt
from PyQt4.QtNetwork import *
from PyQt4.QtCore import pyqtSignal 

# Import the matplotlib module
import matplotlib as mplib
# Import the FigureCanvas object from matplotlib, this is the canvas on which the figure is drawn in the GUI.
from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
# Import the navigation toolbar -- shown on the figure in the GUI. (having options such as zoom, save etc.)
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as NavigationToolbar
# Import Figure -- actual figure object containing the matplotlib figure in the GUI
from matplotlib.figure import Figure
# FuncFormatter is the function to do a custom formatting of the figure axis. 
from matplotlib.ticker import FuncFormatter
# SpanSelector is the function for selecting a portion of the plot graphically using the mouse.
from matplotlib.widgets import SpanSelector

# InternalShell is the python shell used in the GUI.
from spyderlib.widgets.internalshell import InternalShell
# NamespaceBrowser and VariableExplorer are used to create the variable explorer table using in the GUI.
from spyderlib.widgets.externalshell.namespacebrowser import NamespaceBrowser
from spyderlib.plugins.variableexplorer import VariableExplorer

import numpy as np
import numpy.lib.recfunctions as nprf

# FFT functions from SciPy
from scipy.signal import fftconvolve
from scipy.fftpack import fftshift, fft

# The GUI MainWindow object from the python code generated using the .ui file
from main_app_gui import Ui_MainWindow

# conf.py contains various configurations such as testmux parameter structures, result filenames etc...
import conf
from filter import *
from triggers import *
from networkClasses import *

  
# testdebuglib is a custom module/library of signal processing functions.
# Currently includes preamble type detection and correlation functions.
import testdebuglib as tdlib

if platform.python_version()[0] == "3":
    raw_input=input
#

class SystemAnalyzer(QtGui.QMainWindow):
    received = QtCore.pyqtSignal(int)   #Signal defined to communicate when a new packet is processed
    def __init__(self, parent=None):

        """ Initialize the GUI application. 
        Connect Signals and Slots within the GUI.
        Create the Python Console and Variable Explorer.
        Initialize variables needed by the application.
        """
        # Initialize the QWidget with the parent (in this case no parent)
        QtGui.QWidget.__init__(self, parent)
        # Center the GUI on the screen
        self.center()
        # Create a Ui_MainWindow object representing the GUI
        self.ui = Ui_MainWindow()
        # Call the setuUi function of the main window object.
        self.ui.setupUi(self)
        # Populate the testmux parameter tree in the GUI.
        self.populate_tree(0)
        # Create a tooltip for the browse button on the GUI.
        self.ui.browseButton.setToolTip("Select the directory where result files are located")
        # Set the folder path text box style to 'cleanlooks'. Acts as an example on how to do it if required and also looks better.
        self.ui.folderPathText.setStyle(QtGui.QStyleFactory.create("Cleanlooks"))

        # Setup the SIGNAL-SLOT connections for the GUI components
        # SIGNAL represents the event on the GUI. eg., clicked, activated, doubleClicked etc...
        # SLOT represents the function which will handle the event, this can be an inbuilt function or a custom function defined in this class.
        self.ui.testMuxSelect.activated.connect(self.populate_tree)
        self.ui.browseButton.clicked.connect(self.get_results_folder)
        self.ui.testModeBox.activated.connect(self.select_mode)
        # To pass extra arguments to a SLOT function we use lambda 
        self.ui.loadButton.clicked.connect(lambda: self.read_load_data(self.ui.testMuxSelect.currentIndex(), self.ui.testModeBox.currentText()))
        self.ui.clearButton.clicked.connect(self.clear_plots)
        #TabWidget  houses Single Plot and Multi Plot Tabs
        self.ui.tabWidget.currentChanged.connect(self.tab_guihandler)
        # ManTabWidget houses top layer Tabbed menu
        self.ui.manTabWidget.currentChanged.connect(self.manTabHandler)
        self.ui.paramTreeView.doubleClicked.connect(self.command_complete)
        self.ui.expandTreeButton.clicked.connect(self.ui.paramTreeView.expandAll)                
        self.ui.detectPacketButton.clicked.connect(self.generate_packet_info)
        self.ui.plotCorrButton.clicked.connect(self.plot_correlations)
        self.ui.plotPSDButton.clicked.connect(self.plot_PSD)
        self.ui.plotConstButton.clicked.connect(self.plot_slicer_constellation)
        self.ui.fsBox.valueChanged.connect(self.update_Fs)
        QtCore.QObject.connect(self.ui.mplPlot, QtCore.SIGNAL("dropped"), self.parameter_dropped)
        QtCore.QObject.connect(self.ui.mplPlotSingle, QtCore.SIGNAL("dropped"), self.parameter_dropped)
        QtCore.QObject.connect(self.ui.mplPlotSingle, QtCore.SIGNAL("selected"), self.subset_selected)
        QtCore.QObject.connect(self.ui.mplPlotSingleIQ, QtCore.SIGNAL("selected"), self.corr_subset_selected)
       
        self.ui.mplPlot.canvas.mpl_connect('pick_event', self.onpick_tooltip)
        self.ui.mplPlotSingle.canvas.mpl_connect('pick_event', self.onpick_tooltip) 

        # Create the Python Console and Variable Explorer Dock Widgets (Based on the widgets/plugins from spyderlib module)
        font = QtGui.QFont("Consolas")
        font.setPointSize(14)
        msg = "NumPy, SciPy, Matplotlib have been imported"
        cmds = ['from numpy import *', 'from scipy import *', 'from matplotlib.pyplot import *']
        # Note: by default, the internal shell is multithreaded which is safer 
        # but not compatible with graphical user interface creation.
        # For example, if you need to plot data with Matplotlib, you will need 
        # to pass the option: multithreaded=False
        # Create a python shell object 
        

        self.console = cons = InternalShell(self, namespace=globals(), message=msg, commands=cmds, multithreaded=False)
        self.console.setMinimumWidth(200)
        # Create a variable explorer object
        self.vexplorer = VariableExplorer(self)
        # Connect the python shell to the variable explorer
        self.nsb = self.vexplorer.add_shellwidget(cons)
        # Set visual properties
        cons.set_font(font)
        cons.set_codecompletion_auto(True)
        cons.set_calltips(True)
        cons.setup_calltips(size=300, font=font)
        cons.setup_completion(size=(200, 150), font=font)

        #self.sendCommandLayout = QtGui.QFormLayout()
       
        self.addLeftMenu()
        self.addStatusWidget()       
        
        
        # Add the python shell to the main gui
        self.console_dock = QtGui.QDockWidget("Python Console", self)
        self.console_dock.setWidget(cons)
        
        # Add the variable explorer to the main gui
        self.vexplorer_dock = QtGui.QDockWidget("Variable Explorer", self)
        self.vexplorer_dock.setWidget(self.vexplorer)
        
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.vexplorer_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.console_dock)
             
        self.ui.menuView.addAction(self.vexplorer_dock.toggleViewAction())
        self.ui.menuView.addAction(self.console_dock.toggleViewAction())

                
#        self.button5.clicked.connect(lambda: self.FSM_Config(0,0,0,0,0,0,0,0,0,0))

        #Connectors for the various ui components

        self.packetsProcessed = 0
        self.FPGAVersion = "10.1.1"
        self.isConnected = False
        self.isArmed = False
        self.isTriggered = False
        self.isCaptured = False
        self.updateStatus()
       
        

        self.captureFilterVBox = Qt.QGridLayout(self.ui.captureFilterFrame)
        self.captureFilterVBox.setAlignment(QtCore.Qt.AlignTop)         
        self.RTFilterVBox = Qt.QGridLayout(self.ui.RTFilterGroup)
        self.RTFilterVBox.setAlignment(QtCore.Qt.AlignTop)
        self.triggerVBox = Qt.QVBoxLayout(self.ui.triggerGroup)
        self.triggerVBox.setAlignment(QtCore.Qt.AlignTop)


        self.ui.bottonCaptureAddFilter.clicked.connect(self.addCaptureFilter)
        self.ui.bottonRTAddFilter.clicked.connect(self.addRTFilter)
        self.ui.buttonTriggerAdd.clicked.connect(self.addNewTrigger)
        self.ui.buttonCaptureReadReg.clicked.connect(self.readCaptureFilters)
        self.ui.pushCaptureSendFilters.clicked.connect(self.sendCaptureFilters)
        self.ui.pushRTSendFilters.clicked.connect(self.sendRTFilters)
        self.ui.buttonRTReadReg.clicked.connect(self.readDripFilters)
        self.ui.bottonCaptureDelFilter.clicked.connect(self.deleteCaptureFilter)
        self.ui.bottonRTDelFilter.clicked.connect(self.deleteRTFilter)
        self.ui.buttonTriggerDelete.clicked.connect(self.deleteTrigger)
        self.ui.bottonCaptureCopyFilter.clicked.connect(self.copyCaptureToRT)
        self.ui.bottonRTCopyFilter.clicked.connect(self.copyRTtoCapture)
        self.ui.buttonAddTriggerLine.clicked.connect(self.addTriggerLine)
        self.ui.triggerSlider.sliderReleased.connect(self.sliderMoved)
        self.ui.buttonFSMRead.clicked.connect(self.readFSMRegisters)
        self.ui.buttonFSMSend.clicked.connect(self.writeFSMRegisters)        
        
        self.ui.FPGAComboMAC.setDuplicatesEnabled(False)
                
      
        self.Triggers=[]
        self.RTFilters=[]
        self.CaptureFilters=[]
        self.filterList = []
        self.baseList = []
        self.rangeList=[]
        self.topList=[]    
        self.packetQueue = []

        
        self.numTriggers = 0
        self.numRTFilters = 0
        self.numCaptureFilters = 0
        self.totalTriggers = 16
        self.totalRTFilters = 16
        self.totalCaptureFilters = 16
        self.queueLength = 0
        
    
        self.filterDictionary = {}
        self.baseDictionary = {}
        self.topDictionary = defaultdict(list)
        self.offsetDictonary = {}
        self.streamToBaseDictionary = {}
        self.basetoStreamDictionary = {}
        
        self.rtFilterHeaders = False
        self.captureFilterHeaders = False
        self.deviceConfigured=False
        self.isConfigured = False

        self.adapterHandle = pcap_t
        self.listening = False
    
    
        

        self.queueLock = threading.Lock()
        
        # READ XML DOCUMENTS AND CREATE THE FILTERS
        with open('Phy_regspec_fusion.xml', 'rt') as f:
            tree = ElementTree.parse(f)


        for bnode in tree.iter('block'):
            bname = bnode.attrib.get('name')
            boffset = bnode.get('offset')           
            for rfile in bnode.iter('regfile'):
                rname = rfile.attrib.get('name')
                self.topDictionary[bname].append(rname)           
                baseName = bname+'_'+rname
                if (rfile.attrib.get ('absolute_addr')):
                    boffset = rfile.attrib.get ('absolute_addr')                  
                #print(baseName+"______"+boffset)
                self.baseDictionary[baseName] = [boffset, "7",[]]
                for node in rfile.iter('reg'):
                    name = node.attrib.get('name')
                    baseItem=self.baseDictionary.get(baseName)
                    baseItem[2].append(name)  
                    offsetName = baseName+'_'+name
                    offt = node.attrib.get('offset')
                    a = Qt.QString(str(offt))
                    a.replace('0x','')
                    offt = str(a)
                    #val1 = a.toInt(16)
                    #a = val1[0] /4      
                    #offt = "{:>}" .format(str(a))
                    self.offsetDictonary[offsetName]=[offt,[]]
                    #offt.replace('0x','')
                    for n in node.iter('field'):
                        n1  = n.attrib.get('name')
                        fieldItem = self.offsetDictonary.get(offsetName)
                        fieldItem[1].append(n1)
                        offset = n.attrib.get('offset')
                        width = n.attrib.get('width')
                        offset1 = int(offset)+int(width)-1
                        offset2 = str(Qt.QString("%1:%2") .arg(offset1)   .arg(offset))
                        offset2 = "{:>}".format(offset2)                        
                        filtername = bname+'_'+rname+'_'+name+'_'+n1
                        #print (filtername)
                        if (n1 !="RESERVED"):
                            filterListElement=[filtername,boffset,"7",offt,offset2]                                                
                            self.filterList.append(filterListElement)                               
                            self.filterDictionary[filtername]=filterListElement
                            #print ("{0} {1}" .format(n1,offset2))                            
       



#   READ XML DOCUMENTS AND CREATE THE FILTERS
         
        self.baseDictionary["eventLogger"] = ["FFFFFFFF", "3",[]]
        
      
        with open('eventLogger.xml', 'rt') as eventfile:
            print (eventfile)            
            eventtree = ElementTree.parse(eventfile)
        for eventnode in eventtree.iter('event'):
            eventname = eventnode.attrib.get('name')
            eventID = eventnode.get('id')           
            baseItem=self.baseDictionary.get("eventLogger")
            baseItem[2].append(eventname)  
            offsetName = "eventLogger"+'_'+eventname                
            offt = str(eventID)
            self.offsetDictonary[offsetName]=[offt,[]]  
            for rfile in eventnode.iter('data'):                
                rname = rfile.attrib.get('name')
                fieldItem = self.offsetDictonary.get(offsetName)
                fieldItem[1].append(rname)
                bitMax = rfile.attrib.get('MSB')
                bitMin = rfile.attrib.get('LSB')
                offset2 = str(Qt.QString("%1:%2") .arg(bitMax)   .arg(bitMin))
                offset2 = "{:>}".format(offset2)                       

                filtername =offsetName +'_'+rname
                
                filterListElement=[filtername,"FFFFFFFF","3",offt,offset2]                                                
                self.filterList.append(filterListElement)                               
                self.filterDictionary[filtername]=filterListElement     
     
       
        self.baseDictionary["TestMux"] = ["FFFFFFFF", "5",[]]
        with open('testMux.xml', 'rt') as eventfile:
            print (eventfile)            
            eventtree = ElementTree.parse(eventfile)
        for eventnode in eventtree.iter('mode'):       
            eventname = eventnode.attrib.get('name')       
            eventID = eventnode.get('id') 
            baseItem=self.baseDictionary.get("TestMux")
            baseItem[2].append(eventname)  
            offsetName = "TestMux"+'_'+eventname                
            offt = str(eventID)
            self.offsetDictonary[offsetName]=[offt,[]]  
            for rfile in eventnode.iter('primary'):
                rname = rfile.attrib.get('name')
                for bfile in rfile.iter('data'):
                    bname = bfile.attrib.get('name')
                    fieldItem = self.offsetDictonary.get(offsetName)
                    bname = rname + '_'+ bname
                    fieldItem[1].append(bname)
                    bitMax = bfile.attrib.get('MSB')
                    bitMin = bfile.attrib.get('LSB')
                    offset2 = str(Qt.QString("%1:%2") .arg(bitMax)   .arg(bitMin))
                    offset2 = "{:>}".format(offset2)  
                    filtername = offsetName+'_'+bname
                    filterListElement=[filtername,"FFFFFFFF","5",offt,offset2]                                                
                    self.filterList.append(filterListElement)                               
                    self.filterDictionary[filtername]=filterListElement  
                    
                    
            for rfile in eventnode.iter('secondary'):
                rname = rfile.attrib.get('name')
                for bfile in rfile.iter('data'):
                    bname = bfile.attrib.get('name')
                    bname = rname + '_'+ bname
                    fieldItem = self.offsetDictonary.get(offsetName)
                    fieldItem[1].append(bname)
                    bitMax = bfile.attrib.get('MSB')
                    bitMin = bfile.attrib.get('LSB')
                    offset2 = str(Qt.QString("%1:%2") .arg(bitMax)   .arg(bitMin))
                    offset2 = "{:>}".format(offset2)  
                    filtername = offsetName+'_'+rname+'_'+bname
                    filterListElement=[filtername,"FFFFFFFF","5",offt,offset2]                                                
                    self.filterList.append(filterListElement)                               
                    self.filterDictionary[filtername]=filterListElement 
       
        self.baseList=self.baseDictionary.keys()
        #print (self.offsetDictonary)
    
      
     
     
        
                            
        # Initialize a dictionary to hold all the GUI Data
        self.guidata = { }
        #initialize a dictionary to hold all Trigger Data
        self.TriggerData = { }        
        # Initialize empty array to hold correlation-subset data
        self.corr_subset = np.empty([])
        # Initialize sampling frequency value (user specified or default)
        self.Fs = self.ui.fsBox.value()*1e6
        # Initialize count to point to the current empty plot in the Multi-plot mode
        self.current_plot_count = 0
        # Initialize empty list to hold markers
        self.markers = []
        # Initialize a empty object to hold the selected ADC IQ Magnitude Envelope plot
        self.selected_collection = None
        # Initialize the list of available plot axes
        self.available_axes = [self.ui.mplPlotSingle.canvas.ax1]
        # Initialize the current plot canvas
        self.current_canvas = self.ui.mplPlotSingle.canvas
        # Show the help text message on the current plot canvas/axes
        self.ui.mplPlotSingle.canvas.ax1.text(0.5, 0.5, 'Drag and Drop Parameter Values \n from the left to plot', color='#11557c', fontsize=20,
               ha='center', va='center', alpha=1.0)

        # Check if the gui_params.txt file exists. If so read the value of the RESULTS_PATH.
        try:
            gui_params = { }
            fp = open('gui_params.txt', 'r')
            for line in fp.readlines():
                gui_params[line.split('=')[0]] = line.split('=')[1]
            self.ui.folderPathText.setText(gui_params['RESULTS_PATH'])
        except:
            pass
     
    
    def addStatusWidget(self):
        self.statusWindow = QtGui.QDockWidget("FPGA STATUS",self)
        statusGroupBox = QtGui.QGroupBox(self.statusWindow)           
        statgrp1 = QtGui.QGroupBox(statusGroupBox)        
        statgrp2 = QtGui.QGroupBox(statusGroupBox)                      
        statvbox = QtGui.QHBoxLayout(statusGroupBox)
        statgrp1layout =  QtGui.QVBoxLayout(statgrp1)    
        statgrp2layout =  QtGui.QVBoxLayout(statgrp2)      
        statvbox.addWidget(statgrp1)
        statvbox.addWidget(statgrp2)    
        self.buttonARM = QtGui.QPushButton("ARM",self)
        self.labelFPGA = QtGui.QLabel("FPGA Version: 10.1.1/NOT CONNECTED",self)     
        self.disarmedRadio = QtGui.QRadioButton('Disarmed')        
        self.armedRadio = QtGui.QRadioButton('Armed')
        self.triggeredRadio = QtGui.QRadioButton('Triggered')
        self.capturedRadio = QtGui.QRadioButton('Captured')   
        statgrp2layout.addWidget(self.disarmedRadio)   
        statgrp2layout.addWidget(self.armedRadio)
        statgrp2layout.addWidget(self.triggeredRadio)
        statgrp2layout.addWidget(self.capturedRadio)        
        self.statRadioGrp = QtGui.QButtonGroup()
        self.statRadioGrp.addButton(self.disarmedRadio)        
        self.statRadioGrp.addButton(self.armedRadio)
        self.statRadioGrp.addButton(self.triggeredRadio)
        self.statRadioGrp.addButton(self.capturedRadio)        
        statgrp1layout.addWidget(self.labelFPGA)
        statgrp1layout.addWidget(self.buttonARM)             
        statusGroupBox.setLayout(statvbox)     
        self.statusWindow.setWidget(statusGroupBox) 
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea,self.statusWindow)              
        self.statusWindow.setFixedHeight(130)
        self.buttonARM.clicked.connect(self.armFPGA)
        self.buttonARM.setDisabled(True)
        self.ui.menuView.addAction(self.statusWindow.toggleViewAction())
        
    def addLeftMenu(self):
        ''' The Docakble Menu on the Left side
            To add to ythe menu, simply add to LeftMenuList  following the examples below
        '''
        self.leftMenuWindow = QtGui.QDockWidget("Operations",self)
        self.LeftMenuGroupBox = QtGui.QGroupBox(self.leftMenuWindow)     
        self.LeftMenuLayout = QtGui.QVBoxLayout(self.LeftMenuGroupBox)
        self.LeftMenuGroupBox.setLayout(self.LeftMenuLayout)
        self.leftMenuList = QtGui.QListWidget()
        self.LeftMenuLayout.addWidget(self.leftMenuList)
        self.leftMenuWindow.setWidget(self.LeftMenuGroupBox) 
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea,self.leftMenuWindow)  
      
        self.leftMenuList.addItem(QtGui.QListWidgetItem("Main Screen"))
        self.leftMenuList.addItem(QtGui.QListWidgetItem("FPGA Connect"))
        self.leftMenuList.addItem(QtGui.QListWidgetItem("FPGA Status"))                
        self.leftMenuList.addItem(QtGui.QListWidgetItem("RT Filter"))
        self.leftMenuList.addItem(QtGui.QListWidgetItem("Capture Filter"))
        self.leftMenuList.addItem(QtGui.QListWidgetItem("Set Trigger"))
        self.leftMenuList.addItem(QtGui.QListWidgetItem("Capture Buffer View"))
        self.ui.menuView.addAction(self.leftMenuWindow.toggleViewAction())
         
        
        ''' Connect ItemClicked Signal from Left menu 
        '''
        self.leftMenuList.itemClicked.connect(self.LeftMenuItemChanged)        
  

    def sliderMoved(self):
        value = self.ui.triggerSlider.value()
        if (value < 15 ):
            value = 5;
        elif (value < 35):
            value = 25;
        elif (value < 60):
            value = 50;
        elif (value < 85):
            value = 75;
        else: 
            value = 95
        self.ui.triggerSlider.setValue(value)
        self.ui.sliderValue.setText(Qt.QString("%1") .arg(value))
      
            
                                
    def manTabHandler(self,index):
        if (index == 0):
            print(index)
        if (index == 1) :
            if (self.deviceConfigured == False):
                self.connectDUT()
                self.deviceConfigured = True
        if (index == 2):
            print ("FSM Register Read/Write")
        if (index == 3):
            if (self.rtFilterHeaders == False):
                ex = filterHeaders(self.RTFilterVBox)
                self.rtFilterHeaders = True
                
        if (index == 4):
            if (self.captureFilterHeaders == False):
                ex = filterHeaders(self.captureFilterVBox)
                self.captureFilterHeaders = True
        if (index == 5):
            print ("Trigger Menu")
        if (index == 6):
            print ("Capture Buffer View")

    def printPacket(self,header,pkt_data):
        LINE_LEN = 16
        print ("%ld:%ld (%ld)\n" % (header.contents.ts.tv_sec,header.contents.ts.tv_usec, header.contents.len))
        ##  Print the packet
        for i in range(1,header.contents.len + 1):
            print ("{0:02x} "  .format(pkt_data[i-1])),
            if (i % LINE_LEN) == 0:
                print ("\n")
        #print ("\n\n")
    
    def deleteRTFilter(self):
        for item in self.RTFilters:
            if (item.checkBox.isChecked()):
                item.deleteFilter(self.RTFilterVBox)
                self.RTFilters.remove(item)
                self.RTFilterVBox.update()
                print(len(self.RTFilters))
        self.numRTFilters = len(self.RTFilters)
    
    
    def copyRTtoCapture(self):
        for item in self.RTFilters:
            if (item.checkBox.isChecked()):
                doesExist = self.isFilterExist(item,self.CaptureFilters)
                if (doesExist is 0  ): 
                    ex = filterItem(self.captureFilterVBox,self.baseList,self.numCaptureFilters+1)
                    ex.copyFilter(item)
                    self.numCaptureFilters = len(self.CaptureFilters)
                    self.CaptureFilters.append(ex)
                    ex.baseVar.currentIndexChanged.connect(lambda: self.baseIndexChanged(ex))
   
                #
                # Add filter to RT 
    
    def copyCaptureToRT(self):
        for item in self.CaptureFilters:
            if (item.checkBox.isChecked()):
                doesExist = self.isFilterExist(item,self.RTFilters)
                if (doesExist == 0  ):                           
                    ex = filterItem(self.RTFilterVBox,self.baseList,self.numRTFilters+1)
                    ex.copyFilter(item)
                    self.numRTFilters = len(self.RTFilters)
                    self.RTFilters.append(ex)
                    ex.baseVar.currentIndexChanged.connect(lambda: self.baseIndexChanged(ex))
               
                
                #
                # Add filter to RT 

    def isFilterExist(self, item, filterList):
        returnValue = 0
        for refFilter in filterList:
            returnValue = refFilter.compareFilter(item)
            if (returnValue == 1):
                 QtGui.QMessageBox.about(self, "Filter Message","Filter  exists                            ")
                 break
            
        return(returnValue)

    def deleteCaptureFilter(self):
        for item in self.CaptureFilters:
            if (item.checkBox.isChecked()):
                item.deleteFilter(self.captureFilterVBox)
                self.CaptureFilters.remove(item)
                self.captureFilterVBox.update()
                print(len(self.CaptureFilters))
        self.numCaptureFilters = len(self.CaptureFilters)             

    def deleteTrigger(self):
        for Group in self.Triggers:
            if (Group.groupBox.isChecked() == True):
                for  item in Group.TriggerLines:                    
                    if (item.checkBox.isChecked()):
                        item.deleteTrigger(self.triggerVBox)
                        Group.TriggerLines.remove(item)
                        self.triggerVBox.update()
                        print(len(self.Triggers))
                if (len(Group.TriggerLines) == 0):
                    Group.deleteTrigger(self.triggerVBox)
                    self.Triggers.remove(Group)
                    self.triggerVBox.update()
        
        self.ui.bottonRTDelFilter.clicked.connect(self.deleteRTFilter)
        self.ui.buttonTriggerDelete.clicked.connect(self.deleteTrigger)            
  
    def LeftMenuItemChanged(self):
        print("Left Menu Item Change")
        index = self.leftMenuList.currentRow()
        print(index)
        self.ui.manTabWidget.setCurrentIndex(index)   
    

    def addCaptureFilter(self):
        if (self.numCaptureFilters < self.totalCaptureFilters):
            ex = filterItem(self.captureFilterVBox,self.baseList,self.numCaptureFilters+1)
            ex.baseVar.currentIndexChanged.connect(lambda: self.baseIndexChanged(ex))
            ex.OffsetVar.currentIndexChanged.connect(lambda: self.offsetIndexChanged(ex))    
            ex.rangeVar.currentIndexChanged.connect(lambda: self.bitRangeIndexChanged(ex))                            
    #        ex.baseVar.editTextChanged.connect(lambda: self.comboTextChanged(ex))
            #ex.groupBox.clicked.connect(lambda: self.enableFilter(ex))
            self.CaptureFilters.append(ex)  
            self.numCaptureFilters = len(self.CaptureFilters)

#    def comboTextChanged(self,filter):
#        print("Combo Text Changed")
#        text = filter.baseVar.currentText()
#        filter.baseVar.model().setFilterFixedString(text)
        
       
   

    def enableFilter(self,filter):
        if (filter.isEnabled): 
            filter.isEnabled = False
        else:
            filter.isEnabled = True
        
    def addRTFilter(self):
        if (self.numRTFilters < self.totalRTFilters):       
            ex = filterItem(self.RTFilterVBox,self.baseList,self.numRTFilters+1)
            ex.baseVar.currentIndexChanged.connect(lambda: self.baseIndexChanged(ex))
            ex.OffsetVar.currentIndexChanged.connect(lambda: self.offsetIndexChanged(ex))
            ex.rangeVar.currentIndexChanged.connect(lambda: self.bitRangeIndexChanged(ex))                
    #        ex.baseVar.editTextChanged.connect(lambda: self.comboTextChanged(ex))     
            self.RTFilters.append(ex)        
            self.numRTFilters = len(self.RTFilters)
        
 
    def baseIndexChanged(self,filter):
        key = str(filter.baseVar.currentText())
        #print("key :",key)
        #print (self.baseDictionary.get(key))   
        if key in  self.baseDictionary.keys():
            baseItem = self.baseDictionary.get(key)
            #print (baseItem)
            filter.baseAddres.setText(baseItem[0])
            filter.streamIDMin.setText(baseItem[1])
            filter.streamIDMax.setText(baseItem[1])
            Offsets = baseItem[2]
            filter.OffsetVar.clear()
            for offset in Offsets:
                filter.OffsetVar.addItem(offset)
           
        else: 
            filter.OffsetVar.clear()

                        
    def  offsetIndexChanged(self,filter):
        key = str(filter.baseVar.currentText())+'_'+ str(filter.OffsetVar.currentText())
        if key in self.offsetDictonary.keys():
            offsetItem = self.offsetDictonary.get(key)
            filter.offsetMin.setText(offsetItem[0])
            filter.offsetMax.setText(offsetItem[0])
            bitVars = offsetItem[1]
            filter.rangeVar.clear()
            for item in bitVars:
                filter.rangeVar.addItem(item)
   
   
    def bitRangeIndexChanged(self,filter):        
        key = str(filter.baseVar.currentText())+'_'+ str(filter.OffsetVar.currentText())+'_'+ str(filter.rangeVar.currentText())
        if key in self.filterDictionary.keys():
            rangeItem = self.filterDictionary.get(key)
            filter.bitRange.setText(rangeItem[4])
        
    
#    def filterIndexChanged(self,filter):
#        key = str(filter.filterVar.currentText())
#        #filterElement = self.filterDictionary[key]
#        #print (filterElement)
#    
#        if key in  self.filterDictionary.keys():
#                 filterElement=self.filterDictionary.get(key)
#                 filter.baseAddres.setText(filterElement[1])
#                 filter.streamIDMax.setText(filterElement[2])
#                 filter.streamIDMin.setText(filterElement[2])
#                 filter.offsetMax.setText(filterElement[3])
#                 filter.offsetMin.setText(filterElement[3])
#                 filter.bitRange.setText(filterElement[4])
#                 print(filterElement)
        
        
    def addNewTrigger(self):
        for Item in self.Triggers:
            Item.groupBox.setChecked(False)
        ex = triggerGroup(self.triggerVBox)
        self.numTriggers = len(self.Triggers)
        self.numTriggers = self.numTriggers + 1        
        self.Triggers.append(ex)
        ex.groupBox.clicked.connect(lambda: self.unCheckTriggerGroups(ex))
        
    def unCheckTriggerGroups(self,tGroup):
        for Item in self.Triggers:
            if (Item != tGroup):
                Item.groupBox.  setChecked(False)
  
    def addTriggerLine(self):
        for  Item in self.Triggers:
            if (Item.groupBox.isChecked() == True):
                ex = triggerItem(Item.hbox,self.filterList,Item.numLines)                
                self.triggerVBox.update()
                Item.numLines = Item.numLines + 1
                ex.lineEdit1.setText(Qt.QString("%1") .arg(Item.numLines))
                Item.TriggerLines.append(ex)  
                print (Item.numLines)
                
                
    
    
    def readCaptureFilters(self):
        cmdCode = 0x60
        data = [0]*64;
        data[0] = cmdCode   
        dst = str(self.ui.FPGAComboMAC.currentText())
        self.sendPacket(self,data,64,dst)
    
        
    def readDripFilters(self):
        cmdCode = 0x61
        data = [0]*64;
        data[0] = cmdCode        
        dst = str(self.ui.FPGAComboMAC.currentText())
        self.sendPacket(self,data,64,dst)
  
        
    def sendCaptureFilters(self):
        print ("Capture Filters to be send")   
        data = [0xFF]*256;
        cmdID = 0x20        
        data[0]= cmdID;
        data[1] = 0 # Padding
        index = 2
        for item in self.CaptureFilters:
            if (item.enableButton.isChecked()):
                decimation= "{0:02x}" .format(int(str(item.decimation.text()),16))
                print(decimation)
                headerMax = "{0:02x}" .format(int(str(item.streamIDMax.text()),16))
                print (headerMax)
                headerMin = "{0:02x}" .format(int(str(item.streamIDMin.text()),16))
                print (headerMin)
                offsetMax = "{0:04x}" .format(int(str(item.offsetMax.text()),16))
                print (offsetMax)
                offsetMin = "{0:04x}" .format(int(str(item.offsetMin.text()),16))
                print (offsetMin)
                data[index] = 0x0
                data[index+1] =int(decimation,16) 
                data[index+2] =int(headerMax,16) 
                data[index+3] =int(headerMin,16)
                data[index+4] =int(offsetMax[0:2],16) 
                data[index+5] =int(offsetMax[2:4],16)  
                data[index+6] =int(offsetMin[0:2],16) 
                data[index+7] =int(offsetMin[2:4],16)             
                index = index + 8
                print (data)
        dst = str(self.ui.FPGAComboMAC.currentText())
        pktSize = self.totalCaptureFilters*8
        self.sendPacket(self,data,pktSize,dst)
            
            
    def sendRTFilters(self):
        print("RT Filters to be Send")
        data = [0xFF]*256;
        cmdID = 0x21        
        data[0]= cmdID;
        data[1] = 0 # Padding
        index = 2
        for item in self.RTFilters:
            decimation= "{0:02x}" .format(int(str(item.decimation.text()),16))
            print(decimation)
            headerMax = "{0:02x}" .format(int(str(item.streamIDMax.text()),16))
            print (headerMax)
            headerMin = "{0:02x}" .format(int(str(item.streamIDMin.text()),16))
            print (headerMin)
            offsetMax = "{0:04x}" .format(int(str(item.offsetMax.text()),16))
            print (offsetMax)
            offsetMin = "{0:04x}" .format(int(str(item.offsetMin.text()),16))
            print (offsetMin)
            data[index] = 0            
            data[index+1] =int(decimation,16)
            data[index+2] =int(headerMax,16) 
            data[index+3] =int(headerMin,16)
            data[index+4] =int(offsetMax[0:2],16)
            data[index+5] =int(offsetMax[2:4],16)  
            data[index+6] =int(offsetMin[0:2],16) 
            data[index+7] =int(offsetMin[2:4],16)             
            index = index + 8
        print (data)
        dst = str(self.ui.FPGAComboMAC.currentText())
        pktSize = self.totalRTFilters*8
        self.sendPacket(self,data,pktSize,dst)
            
            
    def readFSMRegisters(self):
        cmdCode = 0x40
        data = [0]*64;
        data[0] = cmdCode        
        dstMac = str(self.ui.FPGAComboMAC.currentText())
        self.sendPacket(self,data,64,dstMac)
        
    def writeFSMRegisters(self):
        print("FSM Registers Written")
        cmdCode = 0x00
        data = [0]*64;
        data[0] = cmdCode 
        ischecked= self.ui.checkboxRunStop.isChecked() 
        trig = self.ui.triggerSlider.value()
        
        if (trig == 5):
            trigPos = 0
        elif (trig == 25):
            trigPos = 1
        elif (trig == 50):
            trigPos = 2
        elif (trig == 75):
            trigPos = 3
        elif (trig == 95):
            trigPos = 4            
                    
        data[6] = ischecked << 7 | trigPos << 4
        data[8] = self.ui.selfGenData.isChecked() << 4 | self.ui.checkBoxExtTrigEnab.isChecked() << 3 |  self.ui.checkBoxExtTrigPol.isChecked() << 2       
        
        dstMac = str(self.ui.FPGAComboMAC.currentText())
        self.sendPacket(self,data,64,dstMac)         
    
    def iptos(in_):
        return "%d.%d.%d.%d" % (in_.s_b1,in_.s_b2 , in_.s_b3, in_.s_b4)

    def ifprint(self,d):
        addres=POINTER(pcap_addr_t)
#        print("%s\n" % d.name)
        self.comboBox.addItem(d.name)
        if d.addresses:
            addres=d.addresses.contents
        else:
            addres=False
#        while addres:
#            if addres.addr.contents.sa_family == sk.AF_INET:
#                mysockaddr_in=sockaddr_in
#                if (addres.addr):
#                    aTmp=cast(addres.addr,POINTER(mysockaddr_in))                     
#                    print ("\tAddress: %s\n" % self.iptos(aTmp.contents.sin_addr.S_un.S_un_b))                   
#            if (addres.next):
#                addres=addres.next.contents
#            else:
#                addres=False
        print ("\n")
        

    
    def startListening(self):
        """ Launch a thread to listen on this interface """ 
        if not self.listening:
            self.listening = True
            threading.Thread(target=self._listen, name="Listener thread, adapter {}".format(self.interface.description)).start()
            threading.Thread(target=self._packetProcessor, name="Processor thread, {}".format(str(self))).start()
            self.received.connect(self.updateStatusWindow)
    

        else:
            "Already listening on adapter {}".format(self.interface.description)
            return(-1)

    def stopListening(self):
        pcap_breakloop(self.listeneradapterHandle)
        print(">> Stopped listening on {}".format(self.interface.description))
        self.listening = False
        self.isConnected = False
        self.ui.buttonConnect.setDisabled(False)
       
        if (self.isArmed):
               self.armFPGA()
               
       
    
    def _listen(self):
        """ Start the network capture on the specified interface. """
        PHAND = CFUNCTYPE(None,POINTER(c_ubyte),
        POINTER(pcap_pkthdr),POINTER(c_ubyte))
        print(">> Listening on {}".format(self.interface.description))
#        pcap_loop(self.listeneradapterHandle, -1, PHAND(self.packet_handler), None)
        pcap_loop(self.listeneradapterHandle, -1, PHAND(self._packetHandler), None) 
        pcap_close(self.listeneradapterHandle)
        
        
        
    def data_to_num(self,data, offset, len):
        """ Convert data from a byte array into an integer (big-endian). """
        num = 0
        for i in xrange(len):
            num <<= 8
            num |= data[offset+i]
        return num

    def _packetHandler(self, param, header, pkt_data):

        """ Parse an intercepted network packet and add to queue. """
        cmdID = self.data_to_num(pkt_data,14,1)
        with self.queueLock:
            self.queueLength += 1
            if (cmdID == 0xC0): 
                self.packetQueue.append(RawPacket(param, header, pkt_data, time.time()))
            else:
                self.packetQueue.insert(0,RawPacket(param, header, pkt_data, time.time()))



    def _packetProcessor(self):
        #received = QtCore.SIGNAL(int)
        while True:
           
            # exit thread if no longer needed
          #print (self.queueLength)
           if self.queueLength == 0:

                if self.listening: continue

                else: break

            # grab a packet off of the packet queue

           
           with self.queueLock:

                packet = self.packetQueue.pop(0) 
               

                self.queueLength -= 1

                # process the packet
           pkt_data = packet.pkt_data
           header = packet.header


           ether_type = self.data_to_num(pkt_data, 12, 2)
           cmdID = self.data_to_num(pkt_data,14,1)
           #print (cmdID)
           source_mac = ":".join([str(hex(self.data_to_num(pkt_data, i, 1))) .replace('0x', '') for i in range(6, 12)])
           #print(">> Received packet type {} from {}".format(hex(ether_type), source_mac))
           #print(">> Packet size {} capture Size {}".format(header.contents.caplen, header.contents.len))
   
           pktLength = header.contents.len
           if (cmdID == 0x80): 
               if (self.isConfigured == False): 
                   self.processDiscoverResponse(pkt_data,pktLength)
               else:
                   self.processTriggerFSMResponse(pkt_data,pktLength)
           elif (cmdID == 0x90):
               self.processTriggerRegResponse(pkt_data,pktLength)
           elif (cmdID == 0xA0):
               self.processCaptureFilterRegResponse(pkt_data,pktLength)
           elif (cmdID == 0xA1):
               self.processDripFilterRegResponse(pkt_data,pktLength)
           elif (cmdID == 0xB0):
               self.processCaptureBufferContentResponse(pkt_data,pktLength)
           elif (cmdID == 0xC0):
               self.processDripData(pkt_data,pktLength)
           elif (cmdID == 0x11):
               self.processDiscoverResponse(pkt_data,pktLength)
           else: 
              print "Unknown Response from FPGA "
            
           self.received.emit(self.packetsProcessed)  
           
           sleep(0.0000001)
           #ether_type = hex(self.data_to_num(packet.pkt_data, 12, 2))
           #source_mac = ":".join([str(hex(self.data_to_num(packet.pkt_data, i, 1))).replace('0x', '') for i in range(6, 12)])
           #dest_mac = ":".join([str(hex(self.data_to_num(packet.pkt_data, i, 1))).replace('0x', '') for i in range(6)])
           #print(">> time {}: processed packet type {} from {} to {}".format(packet.timestamp, ether_type, source_mac, dest_mac))
           #sleep(0.001)
           #self.ui.queuedPackets.setText(Qt.QString("%1") .arg(self.queueLength))
           #self.packetsProcessed  = self.packetsProcessed  + 1
           #self.ui.processedPackets.setText(Qt.QString("%1") .arg(self.packetsProcessed))    
           
    def updateStatusWindow(self):
         
           self.ui.queuedPackets.setText(Qt.QString("%1") .arg(self.queueLength))
           self.packetsProcessed  = self.packetsProcessed  + 1
           self.ui.processedPackets.setText(Qt.QString("%1") .arg(self.packetsProcessed))    

        
    def packet_handler(self,param,header,pkt_data):
        """ Handle an intercepted network packet. """
        ether_type = self.data_to_num(pkt_data, 12, 2)
        cmdID = self.data_to_num(pkt_data,14,1)
        print (cmdID)
        source_mac = ":".join([str(hex(self.data_to_num(pkt_data, i, 1))) .replace('0x', '') for i in range(6, 12)])
        print(">> Received packet type {} from {}".format(hex(ether_type), source_mac))
        print(">> Packet size {} capture Size {}".format(header.contents.caplen, header.contents.len))
        pktLength = header.contents.len
        if (cmdID == 0x80): 
            if (self.isConfigured == False): 
                self.processDiscoverResponse(pkt_data,pktLength)
            else:
                self.processTriggerFSMResponse(pkt_data,pktLength)
        elif (cmdID == 0x90):
            self.processTriggerRegResponse(pkt_data,pktLength)
        elif (cmdID == 0xA0):
            self.processCaptureFilterRegResponse(pkt_data,pktLength)
        elif (cmdID == 0xA1):
            self.processDripFilterRegResponse(pkt_data,pktLength)
        elif (cmdID == 0xB0):
            self.processCaptureBufferContentResponse(pkt_data,pktLength)
        elif (cmdID == 0xC0):
            self.processDripData(pkt_data,pktLength)
        elif (cmdID == 0x11):
            self.processDiscoverResponse(pkt_data,pktLength)
        else: 
            print "Unknown Response from FPGA "
            self.printPacket(header,pkt_data)
        

    def processTriggerFSMResponse(self,pkt_data,pktlen):
        print "Processig Trigger FSM Response"
        seqNum = int(pkt_data[15])

        self.ui.fpgaVersion.setText(Qt.QString("%1") .arg(self.data_to_num(pkt_data,16,1)))
        self.FPGAVersion = self.data_to_num(pkt_data,16,1)
        self.ui.numTrigger.setText(Qt.QString("%1") .arg(self.data_to_num(pkt_data,17,1)))
        self.ui.numCaptureFilter.setText(Qt.QString("%1") .arg(self.data_to_num(pkt_data,18,1)))
        self.ui.numDripFilter.setText(Qt.QString("%1") .arg(self.data_to_num(pkt_data,19,1)))
        self.totalTriggers = self.data_to_num(pkt_data,17,1)
        self.totalRTFilters = self.data_to_num(pkt_data,19,1)
        self.totalCaptureFilters = self.data_to_num(pkt_data,18,1)
        runStop = pkt_data[20] >> 7;
        self.ui.checkboxRunStop.setChecked(runStop)
        trigPos = (pkt_data[20] >> 4) & 0x07
        if (trigPos == 0 ):
            value = 5;
        elif (trigPos == 1):
            value = 25;
        elif (trigPos == 2):
            value = 50;
        elif (trigPos == 3):
            value = 75;
        else: 
            value = 95
        self.ui.triggerSlider.setValue(value)
        self.ui.sliderValue.setText(Qt.QString("%1") .arg(value))
        
        fifoOver = (pkt_data[20] & 0x0F) << 12 | pkt_data[21] << 3 | pkt_data[22] >> 5
        self.ui.fifoOverflow.setText(Qt.QString("%1") .arg(fifoOver))
        selfGen = (pkt_data[22] & 0x10 ) >> 4
        self.ui.selfGenData.setChecked(selfGen)
        
        exTrigEn = (pkt_data[22] >> 3) & 0x01
        exTrigPol = (pkt_data[22] >> 2) & 0x01
        self.ui.checkBoxExtTrigEnab.setChecked(exTrigEn)
        self.ui.checkBoxExtTrigPol.setChecked(exTrigPol)
        status = pkt_data[22] & 0x03;
        
        if (status == 0):
            self.ui.radioIdle.setChecked(True)
        elif (status == 1): 
            self.ui.radioArmed.setChecked(True)
            self.isArmed = True
        elif (status == 2):
            self.ui.radioTriggered.setChecked(True)
            self.isTriggered=True
        else:
            self.ui.radioCaptured.setChecked(True)
            self.isCaptured=True
                  
        self.ui.currentTriggerBlock.setText(Qt.QString("%1") .arg(pkt_data[23]))
      
        self.updateStatus()
        
             
         
            
            
    def processTriggerRegResponse(pkt_data,pktlen):
        print "Processing Trigger Register Response"
        seqNum = int(pkt_data[15])
        

    def processCaptureFilterRegResponse(self,pkt_data,pktlen):
        print "Processing Capture Filter Register Response"
        seqNum = int(pkt_data[15])
        padding = int(pkt_data[15])
        index = 16  
       
        for i in range(0,len(self.CaptureFilters),1):
            index = index + 1
            ex = self.CaptureFilters[i]
            decimation= self.data_to_num(pkt_data,index,1)
            index = index + 1
            headerMax = self.data_to_num(pkt_data,index,1)
            index = index + 1
            headerMin = self.data_to_num(pkt_data,index,1)
            index = index + 1
            offsetMax = self.data_to_num(pkt_data,index,2)
            index = index + 2
            offsetMin = self.data_to_num(pkt_data,index,2)
            index = index + 2
            ex.decimation.setText(Qt.QString("%1") .arg(decimation))
            ex.baseAddres.setText(Qt.QString("%1") .arg(0))
            ex.streamIDMin.setText(Qt.QString("%1") .arg(headerMin)) 
            ex.streamIDMax.setText(Qt.QString("%1") .arg(headerMax)) 
            ex.offsetMin.setText(Qt.QString("%1") .arg(offsetMin))
            ex.offsetMax.setText(Qt.QString("%1") .arg(offsetMax)) 
            ex.bitRange.setText(Qt.QString("%1") .arg(0))
            self.captureFilterVBox.update()
            
            
    def processDripFilterRegResponse(self,pkt_data,pktlen):
        print "Processing Drip Filter Register Response"
        seqNum = int(pkt_data[15])
        padding = int(pkt_data[15])
        index = 16  
       
        for i in range(0,len(self.RTFilters),1):
            index = index + 1
            ex = self.RTFilters[i]
            decimation= self.data_to_num(pkt_data,index,1)
            index = index + 1
            headerMax = self.data_to_num(pkt_data,index,1)
            index = index + 1
            headerMin = self.data_to_num(pkt_data,index,1)
            index = index + 1
            offsetMax = self.data_to_num(pkt_data,index,2)
            index = index + 2
            offsetMin = self.data_to_num(pkt_data,index,2)
            index = index + 2
            ex.decimation.setText(Qt.QString("%1") .arg(decimation))
            ex.baseAddres.setText(Qt.QString("%1") .arg(0))
            ex.streamIDMin.setText(Qt.QString("%1") .arg(headerMin)) 
            ex.streamIDMax.setText(Qt.QString("%1") .arg(headerMax)) 
            ex.offsetMin.setText(Qt.QString("%1") .arg(offsetMin))
            ex.offsetMax.setText(Qt.QString("%1") .arg(offsetMax)) 
            ex.bitRange.setText(Qt.QString("%1") .arg(0))
        
                 

            
    def processCaptureBufferContentResponse(self,pkt_data,pktlen):
        print "Processing Drip Filter Content Response"
        index = 15
        memoryAddress = self.data_to_num(pkt_data,index+15,4)
        readLength =  self.data_to_num(pkt_data,index+19,2)
        EvetLoggerData = []
        TestMuxData = []
        CsBuffData = []
        MemoryMonData = []
        DMADataData = []
        PeriodicMonData = []
        for index in range(21,len(pkt_length,5)):
            strType = self.data_to_num(pkt_data,index,1)
            value   = self.data_to_num(pkt_data,index+1,4)
                #TODO 
                # Create a multidimentional List and add value to one of the lists 
                # based on strTye
                    
    def processDripData(self,pkt_data,pktlen):
        #print "Processing Drip Filter Data"
        seqNum = int(pkt_data[15])
    
        for index in range(16,pktlen,7):
            RTType = pkt_data[index]
            RTOffset = self.data_to_num(pkt_data,index+1,2)
            RTData = self.data_to_num(pkt_data,index+3,4)
            #self.updateRTData(RTType, RTData, RTOffset)
                
            
    def updateRTData(self,RTType, RTData, RTOffset):
        print ("Update Drip Data")
            # RTType (TDB:1, RBD:1, Armed:1, Triggered:1, Hdr:4)
            #TODO  Update the data
          
            
    def processDiscoverResponse(self,pkt_data,pktlen):
        print "Processing Discover Response"
        FPGA_mac = ":" .join([str(hex(self.data_to_num(pkt_data, i, 1))) .replace("0x","0") for i in range(6, 12)])
        self.ui.FPGAComboMAC.setDuplicatesEnabled(False)
        self.ui.FPGAComboDUT.setDuplicatesEnabled(False)
        self.ui.FPGAComboMAC.addItem(FPGA_mac)
        self.ui.FPGAComboDUT.addItem(FPGA_mac)
        self.isConnected = True
        self.isConfigured=True
        self.updateStatus()

        
        
    def discoverFPGA(self):
        cmdCode = 0x40
        data = [0]*64;
        data[0] = cmdCode        
        
        inputFile = open("DUTS.txt")
        while 1:           
            line = inputFile.readline()
            if not line:
                break
            #self.ui.FPGAComboDUT.addItem(line.strip())
            line = inputFile.readline()
            #self.ui.FPGAComboMAC.addItem(line.strip())
            dstMac = line.strip()
            self.sendPacket(self,data,64,dstMac)
            sleep(1)
            print("Discover Message Send")
       
       
        inputFile.close();          
        sleep(1)
        self.isConfigured = False
        
#        dstMac = "FF:FF:FF:FF:FF:FF"
#        self.sendPacket(self,data,64,dstMac)
#        print("Discover Message Send")
  
   
    
    def sendPacket(self,param,packetData,pktLength,dst):
        if (self.listening == False):
            QtGui.QMessageBox.about(self, "Network Driver is not Enabled","Please Enable the Driver and  Discover the DUTs")
            self.ui.manTabWidget.setCurrentIndex(1)
           #QtGui.QMessageBox.about(self, "DUT is not Connected", "Text1 = %s, Text2 = %s" % ("Yusuf", "Ozturk"))
            return

 #       print packetData
        packet=(c_ubyte * 1500)()
        srcMac = str(self.ui.HOSTComboMAC.currentText())
        destMac = dst        
        #destMac = str(self.ui.FPGAComboMAC.currentText())
        #destMac = str(self.ui.FPGAComboMAC.currentText())
        intMacAddr = [int(byte, 16) for byte in srcMac.split(':')]
        destMac = [int(byte, 16) for byte in destMac.split(':')]
        ## set destination mac address
        for i in range(6):
            packet[i] = int(destMac[i])
        # set source mac address
        for i in range(6, 12):
            packet[i] = intMacAddr[i-6]
        ## Fill the rest of the packet
     
        packet[12] = 0x05;
        packet[13] = 0x00;
       
        for i in range(14,pktLength+14):
            packet[i]=packetData[i-14]
        # attempt sending the packet
        #for k in range(1,100):
        #   time.sleep(5)
        if (pcap_sendpacket(self.senderadapterHandle, packet, 14+pktLength) != 0):
            print ("\nError sending the packet: %s\n" % pcap_geterr(self.senderadapterHandle))



    def connectDUT(self): 
        self.ui.HOSTComboIP.setDisabled(True)
        self.ui.HOSTComboMAC.setDisabled(True)
        
        self.ui.buttonDiscover.setDisabled(True)
        self.ui.buttonDisconnect.setDisabled(True)
        
        self.ui.buttonDisconnect.clicked.connect(self.stopListening)
        self.ui.buttonConnect.clicked.connect(self.connectDUTAccepted)
        self.ui.buttonDiscover.clicked.connect(self.discoverFPGA)
        self.ui.buttonChooseDirectory.clicked.connect(self.chooseDirectory)
    
        
        self.ui.HOSTComboInterface.currentIndexChanged.connect(self.NetworkInterfaceChanged)
        self.ui.FPGAComboDUT.currentIndexChanged.connect(self.DUTChanged)
      
        alldevs=POINTER(pcap_if_t)()
        d=POINTER(pcap_if_t)
        errbuf= create_string_buffer(PCAP_ERRBUF_SIZE)

        ## Retrieve the device list
        if (pcap_findalldevs(byref(alldevs), errbuf) == -1):
            print ("Error in pcap_findalldevs: %s\n" % errbuf.value)
           # sys.exit(1)
        
        numInterfaces = 0;
        d=alldevs.contents
        self.interfaces = []
        while d:
            self.interfaces.append(d)
            self.ui.HOSTComboInterface.addItem(d.name)            
            numInterfaces = numInterfaces + 1
            if d.next:
                d=d.next.contents
            else:
                d=False
        all_Addresses = QNetworkInterface.allAddresses()    
        all_info = QNetworkInterface().allInterfaces()
     
#        for i in range(3,len(all_Addresses),2):
        interface = 0
        for i in range(3,len(all_Addresses),2):
           self.ui.HOSTComboIP.addItem(all_Addresses[i].toString())
           interface = interface + 1
           if (interface == numInterfaces):
                break
            
        interface = 0
        for i in range(1,len(all_info),1):
            self.ui.HOSTComboMAC.addItem(all_info[i].hardwareAddress())
            interface = interface + 1
            if (interface == numInterfaces):
                break
        

#        inputFile = open("DUTS.txt")
#        while 1: 
#            
#            line = inputFile.readline()
#            if not line:
#                break
#            self.ui.FPGAComboDUT.addItem(line.strip())
#            line = inputFile.readline()
#            self.ui.FPGAComboMAC.addItem(line.strip())
#           
#        inputFile.close();            
        
    def chooseDirectory(self):
        """ (Slot) Browse and get the results folder. """
        file_dialogobj = QtGui.QFileDialog()
        file_dialogobj.setFileMode(2)
        path = unicode(file_dialogobj.getExistingDirectory(self, 'Choose Results Directory'))
        self.ui.directoryName.setText(path)


       
        
    def connectDUTAccepted(self):
      
        #self.macAddr = macAddr
        #self.intMacAddr = [int(byte, 16) for byte in macAddr.split(':')]
        errbuf= create_string_buffer(PCAP_ERRBUF_SIZE)
        self.interface = self.interfaces[self.ui.HOSTComboInterface.currentIndex()]
        print self.interface.name
        self.senderadapterHandle = pcap_open_live(self.interface.name,65536,PCAP_OPENFLAG_PROMISCUOUS ,1000,errbuf)
        if not bool(self.senderadapterHandle):
            raise Exception("\nUnable to open adapter: {}\n" .format(interface))
        self.listeneradapterHandle = pcap_open_live(self.interface.name,65536,PCAP_OPENFLAG_PROMISCUOUS ,1000,errbuf)
        if not bool(self.listeneradapterHandle):
            raise Exception("\nUnable to open adapter: {}\n" .format(interface))
        #pcap_compile(self.listeneradapterHandle,funct,"ip proto \\tcp")
        #filterstatus = pcap_setfilter(self.listeneradapterHandle,funct)
        
        program=bpf_program()
        mask=0xffffff
        
        if(pcap_compile(self.listeneradapterHandle,program,"ether host  01:00:01:00:00:00  or ether host 01:00:00:00:00:00",c_int(1),mask) == -1):
            # this requires we call pcap_geterr() to get the error
            print("Error could not compile bpf filter because {0}".format(errbuf.value))
        else:
            print("Filter Compiled!")


        if(pcap_setfilter(self.listeneradapterHandle,program)):
            print("Error couldn't install filter {0}".format(errbuf.value))
            #sys.exit(0)
        else:
            print("Filter installed!")
        
        
        self.startListening()
        self.isConnected = False
        self.isArmed = False
        self.isTriggered = False
        self.isCaptured = False
        self.ui.buttonConnect.setDisabled(True)
        self.buttonARM.setDisabled(False)
        self.ui.buttonDiscover.setDisabled(False)
        self.ui.buttonDisconnect.setDisabled(False)
        
        self.updateStatus()

 
 
    def updateStatus(self):
        if (self.isConnected):
            self.FPGAConnected = "CONNECTED"
        else:
            self.FPGAConnected = "NOT CONNECTED"
            
        self.labelFPGA.setText(Qt.QString("FPGA Version:%1 / %2") .arg(self.FPGAVersion)
                                                                  .arg(self.FPGAConnected))
        if (self.isArmed):
            self.armedRadio.setChecked(True)
            self.buttonARM.setText("DISARM")
        else:
            self.disarmedRadio.setChecked(True)
            self.buttonARM.setText("ARM")
            

        if (self.isTriggered):
            self.triggeredRadio.setChecked(True)                                                    
            
        if (self.isCaptured):
            self.capturedRadio.setChecked(True)
   
        self.buttonARM.setDisabled(not(self.isConnected))
                                                 
  

        
    def armFPGA(self):
        if (self.isArmed):
            self.buttonARM.setText("ARM")
            self.isArmed = False
        else:
            self.isArmed = True
            self.buttonARM.setText("DISARM")
                  
        self.updateStatus()
        
 
        
    def NetworkInterfaceChanged(self):
        index = self.ui.HOSTComboInterface.currentIndex()        
        self.ui.HOSTComboIP.setCurrentIndex(index)
        self.ui.HOSTComboMAC.setCurrentIndex(index)
                
    def DUTChanged(self):
        index = self.ui.FPGAComboDUT.currentIndex()        
        self.ui.FPGAComboMAC.setCurrentIndex(index)
        
    def center(self):
        """ Position the GUI at the center of the screen """
        qr = QtCore.QRect(0, 0, 1360, 768)
        cp = QtGui.QDesktopWidget().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())
    
    def closeEvent(self, event):
        """ Executes on closing the GUI Application.
        Exits interpreter and stores the 
        location of the results directory into a .txt file.
        """
        self.console.exit_interpreter()
        event.accept()
        # Store the results path used
        fp = open('gui_params.txt', 'w')
        fp.write('RESULTS_PATH=' + str(self.ui.folderPathText.text()))
        fp.close()
    
    def update_Fs(self, i):
        """ (Slot) Update sampling frequency. """
        self.Fs = i*1e6

    def run_python_script(self):
        """ (Slot) Run a custom python script. """
        file_choices = ""
        pyfilepath = unicode(QtGui.QFileDialog.getOpenFileName(self, 'Select a Python script', '', file_choices))
        if pyfilepath[-3:] == '.py':
            self.console.interpreter.execfile(pyfilepath)

    def set_trigger(self):
        ##
        i = 1
        
    def get_results_folder(self):
        """ (Slot) Browse and get the results folder. """
        file_dialogobj = QtGui.QFileDialog()
        file_dialogobj.setFileMode(2)
        path = unicode(file_dialogobj.getExistingDirectory(self, 'Choose Results Directory'))
        self.ui.folderPathText.setText(path)

    def select_mode(self, index):
        """ (Slot) Check if Logic Analyzer/genvec mode. """
        if index == 0:
            self.ui.genvecTestNumberBox.setEnabled(False)
        else:
            self.ui.genvecTestNumberBox.setEnabled(True)

    def build_parameter_tree(self, parent, elements):
        """ (Utility) Create a model representing the parameter 
        tree using pre-defined list-tuple data structure.
        """
        # Recursively call the function on children starting 
        # from root to build the parameters tree
        # Refer to the test mux parameter trees defined in conf.py
        for text, children in elements:
            item = QtGui.QStandardItem(text)
            parent.appendRow(item)
            if children:
                self.build_parameter_tree(item, children)

    def populate_tree(self, index):
        """ (Slot) Populate the parameter tree based 
        on the Test Mux Configuration selection. 
        """
        self.tree_data = eval('conf.TEST_MUX_CONFIG_' + str(index+1))
        self.get_tree_children(self.tree_data, 0)
        if ('SlicerInputMSBsI' in self.param_list) or ('SlicerInputMSBsQ' in self.param_list):
            self.ui.plotConstButton.setEnabled(True)
        else:
            self.ui.plotConstButton.setEnabled(False)

        # Create a model and use the treeview widget 
        # to display the model (test mux parameter tree)
        self.param_model = QtGui.QStandardItemModel()
        self.build_parameter_tree(self.param_model, self.tree_data)
        self.ui.paramTreeView.setModel(self.param_model)
        # Set the header of the tree to 'Parameters', 
        # self.tr() is used for translation of the string
        self.param_model.setHorizontalHeaderLabels([self.tr("Parameters")])

    def parameter_dropped(self):
        """ (Slot) Wrapper to handle parameter dropped on the plot. """
        try:
            self.create_plot()
        except:
            error_msg_obj = QtGui.QMessageBox()
            error_msg_obj.critical(self, 'Error', 'Parameter not present.')

    def create_plot(self):
        """ (Utility) Create the appropriate plot(s). """
        index = self.ui.paramTreeView.selectedIndexes()[0]
        treeitem_object = index.model().itemFromIndex(index)
        treeitem_text = str(treeitem_object.text())
       
        # Based the current user selected tab (multiplot v/s singleplot) 
        # select the appropirate figure axes
        if self.ui.tabWidget.currentIndex() == 1:
            current_ax = self.available_axes[self.current_plot_count] 
        else:
            current_ax = self.available_axes[0]

        if not self.ui.plotHoldBox.isChecked():
            current_ax.clear()

        # Change to step type plots for binary signals
        if np.max(self.guidata[treeitem_text]) > 1:
            plot_style = 'default'
        else:
            plot_style = 'steps'
        
        if self.ui.testModeBox.currentText() == 'Logic Analyzer':
            current_ax.plot(self.guidata['Time'], self.guidata[treeitem_text], picker=True, drawstyle=plot_style, linestyle='-', label=treeitem_text)
            xaxis_formatter = FuncFormatter(self.time_axis_ticks)
            current_ax.xaxis.set_major_formatter(xaxis_formatter)
        elif self.ui.testModeBox.currentText() == 'genvec':
            current_ax.plot(self.guidata[treeitem_text], picker=True, drawstyle=plot_style, linestyle='-', label=treeitem_text)
        current_ax.legend(prop={'size':10})

        # When using the multiplot circulate through the plots using a mod-counter
        if self.ui.tabWidget.currentIndex() == 1:
            if self.current_plot_count != 3:
                mplib.artist.setp(current_ax.get_xticklabels(), visible=False)
            self.current_plot_count = (self.current_plot_count + 1) % 4

        # Draw the figure on the canvas
        self.current_canvas.draw()

    def clear_plots(self):
        """ (Slot) Clear the plots. """
        # Clearing the plots
        for ax in self.available_axes:
            ax.clear()
            mplib.artist.setp(ax.get_xticklabels(), visible=False)
        self.current_canvas.draw()

        # Clearing markers in the marker table
        self.ui.markerTableWidget.clearContents()
        for row_num in reversed(range(self.ui.markerTableWidget.rowCount())):
            self.ui.markerTableWidget.removeRow(row_num)

        # Re-initialize the plot count to 0
        if self.ui.tabWidget.currentIndex() == 1:
            self.current_plot_count = 0

    def get_tree_children(self, param_tree, calltype = 0):
        """ (Utility) Extract the child nodes (leaf nodes) of the parameter tree. """
        if calltype == 0:
            self.param_list = []
        for text, children in param_tree:
            if children:
                self.get_tree_children(children, 1)
            else:
                self.param_list.append(text)

    def read_load_data(self, index, testmode = 'Logic Analyzer'):
        """ (Slot) Read the specified results file and load the data into a dictionary object. """
        print " Loading Data from Results File ... "
        if testmode == 'Logic Analyzer':
            filename = eval('conf.TEST_MUX_RESULTS_FILE_' + str(index+1))
            filepath = str(self.ui.folderPathText.text()) + '/' + filename
            self.guidata = { }
            try:
                record_array = np.genfromtxt(filepath, delimiter=',', names=True, converters = {'Time': lambda s: self.time_formatter(s), 'ADC_I': lambda s: self.convert_to_signed(s), \
                        'ADC_Q':  lambda s: self.convert_to_signed(s)})  
                for key in record_array.dtype.names:
                    if key == "Time":
                        self.guidata[key] = record_array[key]
                    else:
                        self.guidata[key] = record_array[key].astype(int)
            except IOError:
                error_msg_obj = QtGui.QMessageBox()
                error_msg_obj.critical(self, 'Error', 'Please select a valid Results Directory')

        elif testmode == 'genvec':
            self.guidata = { }            
            dt = (1/self.Fs)*1e3
            self.get_tree_children(self.tree_data, 0)
            for parameter in self.param_list:
                try:
                    if parameter == 'ADC_I':
                        ss_prefix = 'sim_node1_'
                    elif parameter == 'ADC_Q':
                        ss_prefix = 'sim_node1_'
                    else:
                        ss_prefix = 'sim_node1_rx_'
                    genvec_parameter_name = ss_prefix + conf.GENVEC_TESTMUX_MAPPING[parameter] + '.block1'
                    filename = str(self.ui.folderPathText.text()) + '/testcase' + str(self.ui.genvecTestNumberBox.currentIndex()+1) + '_checker/' + genvec_parameter_name
                    filedata = np.loadtxt(filename, dtype=int, skiprows=1)
                    if parameter == 'ADC_Q' or parameter == 'SlicerInputMSBsQ':
                        self.guidata[parameter] = filedata[:,2]
                    else:
                        self.guidata[parameter] = filedata[:,1]
                except (KeyError, IndexError):
                    pass
                except IOError:    
                    error_msg_obj = QtGui.QMessageBox()
                    error_msg_obj.critical(self, 'Error', 'Please select a valid Results Directory')
                    break
        try:
            self.ui.mplPlotSingleIQ.canvas.ax1.clear()
            self.ui.mplPlotSingleIQ.canvas.ax1.plot(abs(self.guidata['ADC_I'] + 1j*self.guidata['ADC_Q']), label='ADC IQ Magnitude Envelope')
            self.ui.mplPlotSingleIQ.canvas.ax1.legend()
            self.selected_collection = None
            print "Done!"
            print "The data can be accessed as follows: tdapp.guidata[name] where 'name' is the parameter name."
            print "E.g., tdapp.guidata['burstDetect'] \n"
            print "Drag-Drop the parameters from the tree to create plots. \n"
            print "To access the selected subset data from the plot, use tdapp.guidata['selected_y'] or tdapp.guidata['selected_x'].\n"

            # Refresh the variable explorer table to update the values shown in the table
            self.refresh_vexplorer_table()
        except:
            pass
       

    def time_formatter(self, s):
        """ (Utility) Custom formatter for reading the 
        time data from the .csv files.
        """
        if s[-3:] == ' ms':
            return float(s[:-3])
        elif s[-3:] == ' us':
            return float(s[:-3])*1e-3
        elif s[-3:] == ' ns':
            return float(s[:-3])*1e-6
        else:
            return 0
    
    def convert_to_signed(self, s):
        """ (Utility) Custom data converter 
        function used in reading files. 
        """
        if s.isdigit():
            s = int(s)
            return s-512
        else:
            return 0

    def time_axis_ticks(self, x, pos):
        """ (Utility) Custom formatter for the Time (X) axis of the plots."""
        return '%5.2f us' % (x*1e3)

    def onpick_tooltip(self, event):
        """ (Slot) Handle the pick event on the Plots. 
        Creates a marker on pick event.
        """
        if self.ui.markerEnabledBox.isChecked() and isinstance(event.artist, Line2D):
            thisline = event.artist
            xdata = thisline.get_xdata()
            ydata = thisline.get_ydata()
            ind = event.ind
            x_points = np.take(xdata, ind)
            y_points = np.take(ydata, ind)
            self.markers.append(x_points[0])
            self.ui.markerTableWidget.insertRow(self.ui.markerTableWidget.rowCount())
            marker_name_item = QtGui.QTableWidgetItem('Marker ' + str(self.ui.markerTableWidget.rowCount()))
            marker_xdata_item = QtGui.QTableWidgetItem(str(x_points[0]))
            marker_ydata_item = QtGui.QTableWidgetItem(str(y_points[0]))
            self.ui.markerTableWidget.setItem(self.ui.markerTableWidget.rowCount()-1, 0, marker_name_item)
            self.ui.markerTableWidget.setItem(self.ui.markerTableWidget.rowCount()-1, 1, marker_xdata_item)
            self.ui.markerTableWidget.setItem(self.ui.markerTableWidget.rowCount()-1, 2, marker_ydata_item)
            for i in range(len(self.available_axes)):
                    self.available_axes[i].axvline(x=x_points[0], linewidth=2, color='r', alpha=0.7)
            self.available_axes[0].text(x=x_points[0], y=y_points[0], s='Marker ' + str(self.ui.markerTableWidget.rowCount()), bbox=dict(facecolor='white', alpha=0.9), color='black')
            self.current_canvas.draw()
        else:
            pass

    def tab_guihandler(self, index):
        """ (Slot) Disable/Enable GUI components based on the 
        tab selection.
        """
        print (index)
        if index == 1:
            self.ui.plotHoldBox.setCheckState(0)
            self.ui.plotHoldBox.setEnabled(False)
            self.available_axes = [self.ui.mplPlot.canvas.ax1, self.ui.mplPlot.canvas.ax2, self.ui.mplPlot.canvas.ax3, self.ui.mplPlot.canvas.ax4]
            self.current_canvas = self.ui.mplPlot.canvas
            for ax in self.available_axes[:-1]:
                mplib.artist.setp(ax.get_xticklabels(), visible=False)
        elif index == 0:
            self.ui.plotHoldBox.setEnabled(True)
            self.available_axes = [self.ui.mplPlotSingle.canvas.ax1]
            self.current_canvas = self.ui.mplPlotSingle.canvas
        else:
            pass

    def command_complete(self, index):
        """ (Slot) Print the parameter variable name corresponding to 
        the tree element on double-click event in the tree.
        """
        index = self.ui.paramTreeView.selectedIndexes()[0]
        treeitem_object = index.model().itemFromIndex(index)
        treeitem_text = str(treeitem_object.text())        
        self.console.insertPlainText('myapp.guidata[' + treeitem_text + ']')

    def subset_selected(self, xmin, xmax):
        """ (Slot) Read and store the subset selected on the singlePlot. """
        try:
            line = self.current_canvas.ax1.get_lines()[0]
            xdata = line.get_xdata()
            ydata = line.get_ydata()
            indmin, indmax = np.searchsorted(xdata, (xmin, xmax))
            indmax = min(len(xdata)-1, indmax)
            selected_xdata = xdata[indmin:indmax]
            selected_ydata = ydata[indmin:indmax]
            self.guidata['selected_y'] = selected_ydata
            self.guidata['selected_x'] = selected_xdata
            self.refresh_vexplorer_table()
        except:
            error_msg_obj = QtGui.QMessageBox()
            error_msg_obj.critical(self, 'Error', 'No data present on the plot!')

    def corr_subset_selected(self, xmin, xmax):
        """ (Slot) Read and store the subset selected on the ADC IQ Magnitude Envelope plot. """
        self.corr_subset = self.guidata['ADC_I'][xmin:xmax] + 1j*self.guidata['ADC_Q'][xmin:xmax]
        if self.selected_collection is not None:
            self.ui.mplPlotSingleIQ.canvas.ax1.collections.remove(self.selected_collection)
        x_axrange = np.arange(xmin, xmax)
        self.selected_collection = mplib.collections.BrokenBarHCollection.span_where(x_axrange, ymin=0, ymax=np.max(np.abs(self.guidata['ADC_I']+1j*self.guidata['ADC_Q'])), 
                                                                        where=np.bitwise_and((x_axrange > xmin), (x_axrange < xmax)), facecolor='green', alpha=0.5)
        self.ui.mplPlotSingleIQ.canvas.ax1.add_collection(self.selected_collection)
    
    def plot_PSD(self):
        """ (Slot) Plot the Power Spectral Density. """    
        try:
            mplib.pyplot.figure()
            mplib.pyplot.psd(self.corr_subset, NFFT=512, Fs=self.Fs)
        except TypeError:
            error_msg_obj = QtGui.QMessageBox()
            error_msg_obj.critical(self, 'Error', 'Please select a subset of the plot shown above')
        else:
            mplib.pyplot.show()

    def plot_slicer_constellation(self):
        """ (Slot) Plot the Slicer input constellation and compute EVM. """
        try:
            error_snr_table = np.loadtxt('snr_table.txt', delimiter=',')
            slicerinput = self.guidata['SlicerInputMSBsI'] + 1j*self.guidata['SlicerInputMSBsQ']
            ideal_xy = np.array([-31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31])
            err = 0
            count = 0 
            err_xsum = 0
            err_ysum = 0
            count_y = 0
            for point in slicerinput:
                if np.real(point) != 0 or np.imag(point) != 0:
                    err_x = np.min(abs(ideal_xy - (np.real(point)/64.0)))
                    err_y = np.min(abs(ideal_xy - (np.imag(point)/64.0)))
                    
                    if np.imag(point) == 1 or np.imag(point) == -1:
                        count_y += 1

                    err_xsum += err_x
                    err_ysum += err_y 
                    err = err + err_x*err_x + err_y*err_y
                    count+=1
            err_n = np.sqrt(err/count)
            min_idx = np.argmin(abs(err_n - error_snr_table[:,0]))
            f = mplib.pyplot.figure()
            ax = f.add_subplot(111)
            mplib.pyplot.plot(self.guidata['SlicerInputMSBsI'], self.guidata['SlicerInputMSBsQ'], 'or', label='Slicer Input Constellation', alpha=0.5)
            mplib.pyplot.text(0.01, 1.02, 'SNR: ' + str(error_snr_table[:,1][min_idx]) + 'dB', transform=ax.transAxes, color='black')
            mplib.pyplot.legend()
            mplib.pyplot.show()
        except TypeError:
            error_msg_obj = QtGui.QMessageBox()
            error_msg_obj.critical(self, 'Error', 'Please select a subset of the plot shown above')

    def plot_correlations(self):
        """ (Slot) Plot the packet correlations with SS, LS and CE. """
        try:
            lstype = self.ui.lsTypeBox.currentText()
            version = self.ui.mocaVersionBox.currentText()
            corr_list = tdlib.corr_functions.get_correlations(self.corr_subset, self.Fs, version, lstype)
            label_list = ['MoCA ' + version + ' SS Correlation', 'MoCA ' + version + ' ' + lstype + ' Correlation', 'MoCA ' + version + ' CE Correlation']
            mplib.pyplot.figure()
            for i, sig in enumerate(corr_list):
                mplib.pyplot.plot(abs(sig), label=label_list[i])
            mplib.pyplot.legend(label_list, prop={'size':10})
            mplib.pyplot.show()
        except TypeError:
            error_msg_obj = QtGui.QMessageBox()
            error_msg_obj.critical(self, 'Error', 'Please select a subset of the plot shown above')
        except UnboundLocalError:
            error_msg_obj = QtGui.QMessageBox()
            error_msg_obj.critical(self, 'Error', 'MoCA 2.0 doesn\'t define LS3/LS4')


    def generate_packet_info(self):
        """ (Slot) Auto detect packet preamble type. """
        try:
            [mocaversion, preamble_types, preamble_config] = tdlib.corr_functions.detect_MoCA_packets(self.corr_subset, self.Fs)
            self.ui.packetInfoTableWidget.insertRow(self.ui.packetInfoTableWidget.rowCount())
            packet_name_item = QtGui.QTableWidgetItem('Packet ' + str(self.ui.packetInfoTableWidget.rowCount()))
            mocaversion_item = QtGui.QTableWidgetItem(mocaversion) 
            preamble_config_item = QtGui.QTableWidgetItem(preamble_config)
            preamble_type_item = QtGui.QTableWidgetItem(preamble_types[0])
            self.ui.packetInfoTableWidget.setItem(self.ui.packetInfoTableWidget.rowCount()-1, 0, packet_name_item)
            self.ui.packetInfoTableWidget.setItem(self.ui.packetInfoTableWidget.rowCount()-1, 1, mocaversion_item)
            self.ui.packetInfoTableWidget.setItem(self.ui.packetInfoTableWidget.rowCount()-1, 2, preamble_config_item)
            self.ui.packetInfoTableWidget.setItem(self.ui.packetInfoTableWidget.rowCount()-1, 3, preamble_type_item)
        except TypeError:
            error_msg_obj = QtGui.QMessageBox()
            error_msg_obj.critical(self, 'Error', 'Please select a subset of the plot shown above')
     
    def refresh_vexplorer_table(self):
        """ (Utility) Refresh variable explorer table"""
        if self.nsb.is_visible and self.nsb.isVisible():
            if self.nsb.is_internal_shell:
                wsfilter = self.nsb.get_internal_shell_filter('editable')
                self.nsb.editor.set_filter(wsfilter)
                interpreter = self.nsb.shellwidget.interpreter
                if interpreter is not None:
                    self.nsb.editor.set_data(self.guidata)
                    self.nsb.editor.adjust_columns()
    
# Entry point of execution
if __name__ == "__main__":
    
    import time

    app = QtGui.QApplication.instance()
    if not app:
        app = QtGui.QApplication(sys.argv)
        # Example for setting a particular style for the GUI.
        #app.setStyle("plastique")

        # Create and display the splash screen
        splash_pix = QtGui.QPixmap('entropic_logo.jpg')
        splash = QtGui.QSplashScreen(splash_pix, QtCore.Qt.WindowStaysOnTopHint)
        splash.setMask(splash_pix.mask())
        splash.show()
        app.processEvents()
        
        # Create an object of the class 
        # defined above (represents the GUI)
        tdapp = SystemAnalyzer()
      
        # Simulate something that takes time
        time.sleep(1)

        # Show the GUI application object created 
        # using the class definition above.
      
        tdapp.show()  
        #tdapp.showMaximized()
  
        splash.finish(tdapp)
        sys.exit(app.exec_())
