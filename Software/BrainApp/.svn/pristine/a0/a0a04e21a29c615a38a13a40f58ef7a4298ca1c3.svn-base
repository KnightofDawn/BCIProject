<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet type="text/xsl" href="PHY_Interface.xsl"?>
<system desc="based on: Hand edited and generated back to PHY_Interface.doc" dl_ldpc_regs_merge_xml_desc="hand editted, based on: PHY_Interface.doc (REVISION 35)" fd_tables_merge_xml_desc="hand editted, based on: PHY_Interface.doc (REVISION 20)" name="reg_htm_parse" td_tables_merge_xml_desc="hand editted, based on: PHY_Interface.doc (REVISION 20)">
  <block name="PhyDl" offset="0xcc150000">
    <regfile desc="PhyDl Tx Csr (static control register)" name="TxCsr" offset="0x0000">
      <reg name="PhyVersionNum" offset="0x000">
        <field access="ru" desc="Revision number of module." name="Revision" offset="0" reset="0" width="8" />
        <field access="ru" desc="Version number of module." name="Version" offset="8" reset="0" width="8" />
        <field access="ru" desc="Indicates module type. PHY = TBS." name="ModuleID" offset="16" reset="0" width="16" />
      </reg>
      <reg name="PhyTxDllCtrl" offset="0x004">
        <field access="rw" desc="0: Tx DLL reset 1: Tx DLL enabled." name="Enable" offset="0" reset="0" width="1" />
        <field access="rw" desc="0: &quot;circular queue&quot; mode 1: &quot;register&quot; mode ... Normal operation uses &quot;circular queue&quot; mode. Repetitive and continuous operation use &quot;register&quot; mode." name="DynCtrlMode" offset="1" reset="x" width="1" />
        <field access="rw" desc="0: normal operation ... 1: loopback Tx DLL to Rx DLL ... Note this bit controls both Tx and Rx." name="LoopbackToRx" offset="2" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="29" />
      </reg>
      <reg name="TxDataPattGen" offset="0x008">
        <field access="rw" desc="When the PN23 pattern is selected InitialPatternState[22:0] is the initial (seed) value of the PN-23 LFSR. Note InitialPatternState[0] is the first bit shifted out of the LFSR; this is consistent with the bit order of the Byte Scrambler LFSR seed but bit-reversed compared to the definition of this parameter in the PHY Systems spec. When the RAMP pattern is selected InitialPatternState[7:0] is the starting value of the ramp. When the TWO-BYTE pattern is selected InitialPatternState[7:0] followed by InitialPatternState[15:8] are the repeating pattern." name="InitialPatternState" offset="0" reset="x" width="23" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="1" />
        <field access="rw" desc="Starts the pattern generator when '1' in continuous or fixed packet modes. Stops the pattern generator when '0' in continuous or fixed packet modes. When stopping in continuous mode the pattern generator ends the packet and stops after generating NumBytes bytes. When stopping in fixed-packet mode the pattern generator stops after the end of the current packet. Not used in replace mode." name="PattStartStop" offset="24" reset="x" width="1" />
        <field access="rw" name="RESERVED" offset="25" reset="x" width="2" />
        <field access="rw" desc="When '0' and set to '1' the internal PattResetPacketStartOnce bit is set to '1'. The internal PattResetPacketStartOnce bit is identical in function to the PattResetPacketStart bit, except it is cleared to '0' following a generated packet and hence only applies to a single packet." name="SetPattResetPacketStartOnce" offset="27" reset="x" width="1" />
        <field access="rw" desc="Selects the operating mode of the pattern generator. 0: replace mode 1: continuous mode 2: fixed packet mode." name="Mode" offset="28" reset="0" width="2" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxErrInsert" offset="0x00c">
        <field access="rw" desc="Initial value of the PN-31 LFSR." name="PnSeed" offset="0" reset="x" width="31" />
        <field access="ru" name="RESERVED" offset="31" reset="x" width="1" />
      </reg>
    </regfile>
  </block>
  <block name="PhyFd" offset="0xcc154000">
    <regfile desc="PhyFd Tx Csr (static control register)" name="TxCsr" offset="0x0000">
      <reg name="PhyTxFdCtrl" offset="0x004">
        <field access="rw" desc="0: Tx FD reset 1: Tx FD enabled." name="Enable" offset="0" reset="0" width="1" />
        <field access="rw" desc="0: &quot;circular queue&quot; mode 1: &quot;register&quot; mode ... Normal operation uses &quot;circular queue&quot; mode. Repetitive and continuous operation use &quot;register&quot; mode." name="DynCtrlMode" offset="1" reset="x" width="1" />
        <field access="rw" desc="0: normal operation 1: loopback Tx FD to Rx FD Note this bit controls both Tx and Rx." name="LoopbackToRx" offset="2" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="29" />
      </reg>
      <reg name="TxFdBerTest" offset="0x008">
        <field access="rw" desc="The initial value of the PN-23 LFSR at packet and/or symbol boundaries as controlled by PnResetPacketStart and PnResetSymStart." name="PnSeed" offset="0" reset="x" width="23" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="4" />
        <field access="rw" desc="When '0' and set to '1' the internal PnResetPacketStartOnce bit is set to '1'. The internal PnResetPacketStartOnce bit is identical in function to the PnResetPacketStart bit, except it is cleared to '0' following a generated packet and hence only applies to a single packet." name="SetPnResetPacketStartOnce" offset="27" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="TxRxDiversityOffset0_0" offset="0x010">
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_3" offset="0" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="6" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_2" offset="8" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_1" offset="16" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="2" />
        <field access="rw" desc="The DivOffset table defines the diversity mapping from output bit position to input bit position (formula in PHY spec)." name="DivOffset_0" offset="24" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxRxDiversityOffset0_1" offset="0x014">
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_7" offset="0" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="6" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_6" offset="8" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_5" offset="16" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_4" offset="24" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxRxDiversityOffset0_2" offset="0x018">
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_11" offset="0" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="6" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_10" offset="8" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_9" offset="16" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_8" offset="24" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxRxDiversityOffset0_3" offset="0x01c">
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_15" offset="0" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="6" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_14" offset="8" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_13" offset="16" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_12" offset="24" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxRxDiversityOffset1_0" offset="0x020">
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_3" offset="0" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="6" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_2" offset="8" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_1" offset="16" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="2" />
        <field access="rw" desc="The DivOffset table defines the diversity mapping from output bit position to input bit position (formula in PHY spec)." name="DivOffset_0" offset="24" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxRxDiversityOffset1_1" offset="0x024">
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_7" offset="0" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="6" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_6" offset="8" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_5" offset="16" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_4" offset="24" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxRxDiversityOffset1_2" offset="0x028">
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_11" offset="0" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="6" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_10" offset="8" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_9" offset="16" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_8" offset="24" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxRxDiversityOffset1_3" offset="0x02c">
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_15" offset="0" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="6" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_14" offset="8" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_13" offset="16" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="2" />
        <field access="rw" desc="See DivOffset[0]." name="DivOffset_12" offset="24" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxShortSeqRef_0" offset="0x030">
        <field access="rw" name="TxShortSeqRef_3" offset="0" reset="x" width="8" />
        <field access="rw" name="TxShortSeqRef_2" offset="8" reset="x" width="8" />
        <field access="rw" name="TxShortSeqRef_1" offset="16" reset="x" width="8" />
        <field access="rw" desc="The TxShortSeqRef array defines the bit sequence used to generate the c.LINK+ short-sequence symbol. Every eighth available subcarrier is BPSK modulated according to the corresponding bit in the TxShortSeqRef array. See Reference Data Order for information on the format." name="TxShortSeqRef_0" offset="24" reset="x" width="8" />
      </reg>
      <reg name="TxShortSeqRef_1" offset="0x034">
        <field access="rw" name="TxShortSeqRef_7" offset="0" reset="x" width="8" />
        <field access="rw" name="TxShortSeqRef_6" offset="8" reset="x" width="8" />
        <field access="rw" name="TxShortSeqRef_5" offset="16" reset="x" width="8" />
        <field access="rw" name="TxShortSeqRef_4" offset="24" reset="x" width="8" />
      </reg>
      <reg name="TxPowerLoad" offset="0x038">
        <field access="rw" desc="Base gain added to each TxPowerLoadGain1 table entry. U&lt;8,0&gt; format." name="GainBase1" offset="0" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="8" reset="x" width="8" />
        <field access="rw" desc="Base gain added to each TxPowerLoadGain0 table entry. U&lt;8,0&gt; format." name="GainBase0" offset="16" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="24" reset="x" width="8" />
      </reg>
      <reg name="FdTestMuxCtrl" offset="0x03c">
        <field access="rw" desc="Currently, only the 6 lsb are used. The field control all the test mux in DLL, FD and TD." name="TestMuxSel" offset="0" reset="x" width="8" />
        <field access="rw" desc="Setting this field to 1 would disable any datapath throttling by the test mux logic. Only set to 1 if errors result from throttling. In RevA silicon. This should be set to '1' when using QAM512 or QAM1024" name="FdTxDisable100MThrottle" offset="8" reset="0" width="1" />
        <field access="rw" desc="This field controls the combined TD, FD and DLL testmux. ... 0: disable test mux. ... 1: normal mode (enable both Tx and Rx signal test mux). ... 2: zero pattern on primary and secondary. ... 3: ones pattern on primary and secondary. ... 4: ones pattern on primary, zeros on secondary. ... 5: up counter (24 bits) on both primary and secondary. ... 6: walking one on primary and secondary (goes from bit 0 to bit 47 continuously). ... 7: walking one on primary only, 0x555555 on secondary." name="Mode" offset="9" reset="x" width="3" />
        <field access="rw" desc="If set, output both primary and secondary test mux signals. This field controls the combined TD, FD and DLL testmux." name="enableSecondary" offset="12" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="13" reset="x" width="19" />
      </reg>
    </regfile>
  </block>
  <block name="PhyTd" offset="0xcc158000">
    <regfile desc="PhyTd Tx Csr (static control register)" name="TxCsr" offset="0x0000">
      <reg name="PhyTxTdCtrl" offset="0x004">
        <field access="rw" desc="0: Tx TD reset 1: Tx TD enabled." name="Enable" offset="0" reset="0" width="1" />
        <field access="rw" desc="0: &quot;circular queue&quot; mode 1: &quot;register&quot; mode ... Normal operation uses &quot;circular queue&quot; mode. Repetitive and continuous operation use &quot;register&quot; mode." name="DynCtrlMode" offset="1" reset="x" width="1" />
        <field access="rw" desc="0: normal operation 1: loopback Tx TD to Rx TDNote this bit controls both Tx and Rx." name="LoopbackToRx" offset="2" reset="x" width="2" />
        <field access="rw" desc="SPARE TXCSR" name="TxCsrSpare" offset="4" reset="x" width="8" />
        <field access="ru" desc="TX CSR STATUS" name="TxCsrSpareStatus" offset="12" reset="x" width="8" />
        <field access="rw" desc="special status mode." name="DynStatusMode" offset="20" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="21" reset="x" width="11" />
      </reg>
      <reg name="TxIfft" offset="0x008">
        <field access="rw" desc="the length of short sequence." name="SsLen" offset="0" reset="x" width="9" />
        <field access="rw" desc="the length of long sequence." name="LsLen" offset="9" reset="x" width="9" />
        <field access="rw" desc="bit 0 for disable SS smoothing, bit 1 for disable LS smoothing, bit 2 for disable CE smoothing." name="TxWinCtrlCya" offset="18" reset="x" width="3" />
        <field access="ru" name="RESERVED" offset="21" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="9" />
      </reg>
      <reg name="TxEppPream" offset="0x00c">
        <field access="rw" desc="1 for conteneous mode, 0 for 1280 samples only." name="Cont" offset="0" reset="x" width="1" />
        <field access="rw" desc="0 for pi/4 offset BPSK modulation. 1 for normal BPSK modulation." name="BpskCya" offset="1" reset="x" width="1" />
        <field access="rw" desc="1 for stopping contineous EPP on packet switch, 0 for endless." name="ContStopCya" offset="2" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="13" />
        <field access="rw" desc="Scale factor for Moca 1.x Preamble short and long sequences and EPP Probe generator. U&lt;12,0&gt; format." name="Scale" offset="16" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="TxPcktGate_0" offset="0x10">
        <field access="rw" desc="window size in which time to start should fall in." name="WinSize" offset="0" reset="x" width="31" />
        <field access="ru" name="RESERVED" offset="31" reset="x" width="1" />
      </reg>
      <reg name="TxPcktGate_1" offset="0x14">
        <field access="rw" desc="Set to 0 for normal mode and every packet would be gated by a PktStartTime. If set to 1, the first packet would use PktStartTime and after that, every packets is gate by a CTC value of RepeatIfg." name="RepeatMode" offset="0" reset="x" width="1" />
        <field access="rw" desc="This ignored in non RepeatMode. This defines the size of the IFG (from packet end to next packet start) in RepeatMode . This field is in 200 Mhz precision." name="RepeatIfg" offset="1" reset="x" width="16" />
        <field access="rw" desc="zeros at packet end ... 0: no zeros ... 1: no zeros ... 2: no zeros ... 3: 16 zeros. (need only bit 18)" name="EndingZerosCya" offset="17" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="19" reset="x" width="13" />
      </reg>
      <reg name="TxTdPream" offset="0x18">
        <field access="rw" desc="Scale factor for short and long seq." name="Scale" offset="0" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="12" reset="x" width="20" />
      </reg>
      <reg name="TdTestMuxCtrl" offset="0x1c">
        <field access="rw" desc="Setting this field to 1 would disable any datapath throttling by the test mux logic. Only set to 1 if errors result from throttling. In RevA silicon, this should be set to 1 when using QAM512 or QAM1024" name="TdTxDisable100MThrottle" offset="0" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="1" reset="x" width="31" />
      </reg>
      <reg name="TxEventLogger_0" offset="0x20">
        <field access="rw" desc="the threshold of which time between arrival and transmit is compared to." name="TxPcktGatePcktLateThld" offset="0" reset="x" width="32" />
      </reg>
      <reg name="TxDigMixer_0" offset="0x24">
        <field access="rw" desc="Fusion2 new add : square waves test outputs (saturated sin/cos)" name="TxDigMixerSatMode" offset="0" reset="x" width="1"></field>
        <field access="rw" desc="Fusion2 new add : there are 4 main modes" name="TxDigMixerMainMode" offset="1" reset="x" width="2"></field>
        <field access="rw" desc="Fusion2 new add : there are 8 sub modes" name="TxDigMixerSubMode" offset="3" reset="x" width="3" />
        <field access="rw" desc="Fusion2 new add : tone2 freq or msb's of sweep_freq" name="TxDigMixerFreq2" offset="6" reset="x" width="20" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="6" />
      </reg>
      <reg name="TxDigMixer_1" offset="0x28">
        <field access="rw" desc="Fusion2 new add : bit[3]==0 Joe's implementation, bit[2]==0 discontinuity chirp, bits[1:0] chirp boundries 100M 50M 25M " name="TxDigMixerChirpCya" offset="0" reset="x" width="1"></field>
        <field access="rw" desc="Fusion2 new add :  test modes are done in a burst mode (using dummy input data)" name="TxDigMixerTestCya" offset="1" reset="x" width="1"></field>
        <field access="rw" desc="Fusion2 new add :  the gain used for the cos table output" name="TxDigMixerFreq1Gain" offset="2" reset="x" width="13" />
        <field access="rw" desc="Fusion2 new add :  the gain used for the sin table output" name="TxDigMixerFreq2Gain" offset="15" reset="x" width="13" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="TxAnalogIfc" offset="0x2c">
        <field access="rw" desc="Fusion2 new add :  disable bias remvoal on non zero data" name="TxAnalogIfcSatCya" offset="0" reset="x" width="1"></field>
        <field access="rw" desc="Fusion2 new add :  DAC representation 1: 2's complement, 0 unsigned" name="TxAnalogIfcD2aIs2c" offset="1" reset="x" width="1"></field>
        <field access="rw" desc="Fusion2 new add :   6 bits I dc bias" name="TxAnalogIfcIDcBias" offset="2" reset="x" width="6"></field>
        <field access="rw" desc="Fusion2 new add :   6 bits Q dc bias" name="TxAnalogIfcQDcBias" offset="8" reset="x" width="6"></field>
        <field access="ru" name="RESERVED" offset="14" reset="x" width="17" />
      </reg>
      <reg name="TxDacOut" offset="0x30">
        <field access="rw" desc="Fusion2 new add :  when asserted dac_out latched to  dac_out_latch_i/q " name="TxDacOutLatchEn" offset="0" reset="x" width="1"></field>
        <field access="rw" desc="Fusion2 new add :   dac real part latch value" name="TxDacOutLatchI" offset="1" reset="x" width="10"></field>
        <field access="rw" desc="Fusion2 new add :   dac imag part latch value " name="TxDacOutLatchQ" offset="11" reset="x" width="10"></field>
        <field access="ru" name="RESERVED" offset="21" reset="x" width="11" />
      </reg>
    </regfile>
  </block>
  <block name="PhyDl" offset="0xcc150000">
    <regfile desc="PhyDl Tx Csbuff (dynamic control register)" name="TxCsbCtl" offset="0x0800" absolute_addr="0xcc150800">
      <mult name="0" num="4" offset="0x100" />
      <reg name="TxDllEntryControl" offset="0x00">
        <field access="rw" desc="Writing a '0' transfers this entry to hardware for processing. Writing a '1' transfers this entry to software for reuse." name="Empty" offset="0" reset="1" width="1" />
        <field access="ru" desc="State of corresponding status entry - see TxDllEntryStatus register description." name="StatusEmpty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Indicates this entry has been processed (but status not necessarily available). 0: not processed 1: processed." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="29" />
      </reg>
      <reg name="TxDllControl" offset="0x04">
        <field access="rw" desc="The packet length modulo 4. Used in 'normal' input mode to determine how many bytes of the last 32-bit input word from the DMA are to be processed. Not used in 'bypass' input mode. ... 0: 4 bytes ... 1: 1 byte ... 2: 2 bytes ... 3: 3 bytes." name="PktLenMod4" offset="0" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="2" reset="x" width="26" />
        <field access="rw" desc="0: normal input (8b) 1: bypass input (32b) Controls how input data from the DMA is processed by the Tx pipeline. In 'normal' input mode 8 bits are processed at a time. In 'bypass' input mode 32 bits are processed at a time." name="InputMode" offset="28" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxDataPattGen" offset="0x08">
        <field access="rw" desc="In replace mode the number of input bytes to pass through without modification before replacing subsequent input bytes with pattern bytes. In fixed packet mode the number of pattern bytes to generate per packet (must be greater than 0). In continuous mode the number of pattern bytes to generate before ending the packet once stop is asserted (must be greater than 0)." name="NumBytes" offset="0" reset="x" width="16" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="8" />
        <field access="rw" desc="0: PN23 ... 1: RESERVED ... 2: RAMP ... 3: TWO-BYTE ... The 'PN23' pattern is the output from a PN-23 (x23 + x5 + 1) LFSR which is compatible with external BER Test equipment. The LFSR is set to the value of InitialPatternState[22:0] at the start of a packet as specified by ResetPacketStartOnce and ResetPacketStart. The 'PN23 Serial' pattern is the least-significant 8 bits of the PN-23 LFSR (see above) that is advanced one position per 8 bits of output. The LFSR is set to the value of InitialPatternState[22:0] at the start of a packet as specified by ResetPacketStartOnce and ResetPacketStart. The 'RAMP' pattern is the value of an 8-bit counter that increments by 1 for each 8 bits of output, wrapping back to 0 after 255. The counter is set to the value of InitialPatternState[7:0] at the start of a packet as specified by ResetPacketStartOnce and ResetPacketStart. The 'TWO-BYTE' pattern is InitialPatternState[7:0] followed by InitialPatternState[15:8], repeated as required, starting with the former at the start of each packet." name="PattSelect" offset="24" reset="x" width="2" />
        <field access="rw" desc="0: Pattern state continues at packet start ... 1: Pattern state initialized at packet start Only used when the PN23, or RAMP patterns are selected. ... When '1' the pattern generator state is initialized at the start of the packet - see InitialPatternState for details. Must be '1' when PattSelect differs from the previous packet (i.e. the pattern is changed) for the state of the pattern generator to be defined." name="PattResetPacketStart" offset="26" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: Pattern generator bypassed 1: Pattern generator enabled. The enable is used in replace mode, continuous and fixed-packet modes." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxRsEnc_0" offset="0x0c">
        <field access="rw" desc="The total number of Reed-Solomon blocks to encode. The first NumBlks-1 blocks are encoded using the InitialK and InitialT parameters. One last block is encoded using the FinalK and FinalT parameters. Must be greater than 0. When 1 the single block is encoded using the final parameters." name="NumBlks" offset="0" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="8" reset="x" width="8" />
        <field access="rw" desc="Reed-Solomon encoder T parameter for the last block. Supported values are 3,4,5,6,8." name="FinalT" offset="16" reset="x" width="6" />
        <field access="rw" desc="Reed-Solomon encoder T parameter for the first NumBlks-1 blocks. Supported values are 3,4,5,6,8." name="InitialT" offset="22" reset="x" width="6" />
        <field access="rw" desc="0: R-S encoder bypassed 1: R-S encoder enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxRsEnc_1" offset="0x10">
        <field access="rw" desc="Reed-Solomon encoder K parameter for the last block. Must be greater than 1 and such that the overall codeword length (N=K+2T) is less than 256." name="FinalK" offset="0" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="8" reset="x" width="8" />
        <field access="rw" desc="Reed-Solomon encoder K parameter for the first NumBlks-1 blocks. Must be greater than 1 and such that the overall codeword length (N=K+2T) is less than 256." name="InitialK" offset="16" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="24" reset="x" width="8" />
      </reg>
      <reg name="TxByteInterleaver" offset="0x14">
        <field access="rw" desc="The number of rows to interleave. Must be greater than 1 (due to implementation limitation). The number of columns times the number of rows must be greater than 6 (due to implementation limitation) and 160 or less." name="NumRows" offset="0" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="1" />
        <field access="rw" desc="The number of columns to interleave. Must be greater than 1 (due to implementation limitation). The number of columns times the number of rows must be greater than 6 (due to implementation limitation) and 160 or less." name="NumCols" offset="8" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="13" />
        <field access="rw" desc="0: Interleaver bypassed 1: Interleaver enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxLdpcEnc_0" offset="0x18">
        <field access="rw" desc="The number of blocks to encode using the InitialK and InitialCodeSel parameters. Any remaining blocks are encoded using the FinalK and FinalCodeSel parameters. A value of 0 encodes all blocks with the 'final' parameters." name="NumInitialBlks" offset="0" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="10" reset="x" width="6" />
        <field access="rw" desc="0: 4608 rate 19/24 1: 576 rate 3/4 Code for remaining blocks after first NumInitialBlks blocks." name="FinalCodeSel" offset="16" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="20" reset="x" width="2" />
        <field access="rw" desc="0: 4608 rate 19/24 1: 576 rate 3/4 Code for the first NumInitialBlks blocks." name="InitialCodeSel" offset="22" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="2" />
        <field access="rw" desc="0: LDPC encoder bypassed 1: LDPC encoder enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxLdpcEnc_1" offset="0x1c">
        <field access="rw" desc="Number of data bits per LDPC codeword for remaining blocks after first NumInitialBlks blocks. The selected LDPC code is shortened as required to this data length. Must be greater than 0 and less than or equal to the native K of the selected code. Restricted to multiple of 8 for OFDMA." name="FinalK" offset="0" reset="x" width="13" />
        <field access="ru" name="RESERVED" offset="13" reset="x" width="3" />
        <field access="rw" desc="Number of data bits per LDPC codeword for the first NumInitialBlks blocks. The selected LDPC code is shortened as required to this data length. Must be greater than 0 and less than or equal to the native K of the selected code. Restricted to multiple of 8 for OFDMA." name="InitialK" offset="16" reset="x" width="13" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxOfdmPadder" offset="0x20">
        <field access="rw" desc="The total number of bytes output by the padder. The OFDM padder will append zero bytes or drop extra bytes to ensure the output is this length. Must be greater than 0." name="NumBytes" offset="0" reset="x" width="16" />
        <field access="rw" desc="1: The OFDM padder uses 0xFF to do byte padding. 0: OFDM padder uses 0x00." name="PadOne" offset="16" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="12" />
        <field access="rw" desc="0: OFDM padder bypassed 1: OFDM padder enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxByteScrambler" offset="0x24">
        <field access="rw" desc="The initial value of the PN-23 LFSR." name="Seed" offset="0" reset="x" width="23" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="5" />
        <field access="rw" desc="0: Byte Scrambler bypassed 1: Byte scrambler enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxErrInsert" offset="0x28">
        <field access="rw" desc="In 'random' mode bits[3:0] specify the shift count 'N' that controls the probability of error. In 'periodic' mode bits[9:0] specify the period in bytes." name="NOrPeriod" offset="0" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="10" reset="x" width="15" />
        <field access="rw" desc="0: random bit errors 1: periodic bit errors." name="Mode" offset="25" reset="x" width="1" />
        <field access="rw" desc="0: PN-31 LFSR continues at packet start 1: PN-31 LFSR set to PnSeed at packet start Only used in 'random' bit errors mode. Must be '1' for the first packet transmitted in 'random' mode for the state of the LFSR to be defined - in particular this applies following a packet transmitted in 'periodic' mode." name="PnResetPacketStart" offset="26" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: Error inserter bypassed 1: Error inserter enabled When not enabled the PN-31 LFSR state is held." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
    </regfile>
  </block>
  <block name="PhyFd" offset="0xcc154000">
    <regfile desc="PhyFd Tx Csbuff (dynamic control register)" name="TxCsbCtl" offset="0x0800" absolute_addr="0xcc154800">
      <mult name="0" num="4" offset="0x100" />
      <reg name="TxFdEntryControl" offset="0x00">
        <field access="rw" desc="Writing a '0' transfers this entry to hardware for processing. Writing a '1' transfers this entry to software for reuse." name="Empty" offset="0" reset="1" width="1" />
        <field access="ru" desc="State of corresponding status entry - see TxFdEntryStatus register description." name="StatusEmpty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Indicates this entry has been processed (but status not necessarily available). 0: not processed 1: processed." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="29" />
      </reg>
      <reg name="TxFdControl" offset="0x04">
        <field access="ru" name="RESERVED" offset="0" reset="x" width="28" />
        <field access="rw" desc="0: normal operation 1: 32-bit bypass FD transmit section mode. In 32-bit bypass mode 32-bit input data is transferred directly to the TD: no processing blocks are active. The implementation may drain the FD pipeline when changing modes - this will impose a minimum IFG after leaving 32-bit bypass mode." name="Mode" offset="28" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxSymbolGen" offset="0x08">
        <field access="rw" desc="0: TxBitLoadTable0 1: TxBitLoadTable1 2: TxBitLoadTable2 3: TxBitLoadTable3." name="BitLoadTableSel" offset="0" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="2" reset="x" width="6" />
        <field access="rw" desc="0: TxRxChanEstRef0 1: TxRxChanEstRef1 2: TxRxChanEstRef2." name="ChanEstRefSel" offset="8" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="10" reset="x" width="6" />
        <field access="rw" desc="0: TxLongSeqRef0 1: TxLongSeqRef1 2: TxLongSeqRef2 3: TxLongSeqRef3." name="LongSeqRefSel" offset="16" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="18" reset="x" width="2" />
        <field access="rw" desc="The number of valid bits minus one (e.g. a value of 2 indicates 3 valid bits) in the last byte in the packet. Bin assignment (both normal and diversity) discards any remaining bits when it has processed at least all of the valid bits in the last byte in the packet at the end of a symbol. A value of 0 (indicating one valid bit) can be blindly specified when the number of bits per OFDM symbol is at least eight." name="NumValidBitsLastByte" offset="20" reset="x" width="3" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="1" />
        <field access="rw" desc="0: No channel est 1: Prepend channel est When '1' a channel estimation symbol is prepended to the packet data symbols." name="ChanEst" offset="24" reset="x" width="1" />
        <field access="rw" desc="0: No long sequence 1: Prepend long sequence." name="LongSeq" offset="25" reset="x" width="1" />
        <field access="rw" desc="0: No short sequence 1: Prepend short sequence." name="ShortSeq" offset="26" reset="x" width="1" />
        <field access="rw" name="RESERVED" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: Normal data ... 1: Diversity 2 bytes ... 2: Diversity 4 bytes ... 3: Diversity 8 bytes ... 4: FD BERT ... Note the receiver supports at most sixteen data repetitions in diversity mode - the number of input bytes per symbol must be at least one-sixteenth the number of active subcarriers. In FD BERT mode the input data is discarded and the test pattern output." name="Mode" offset="28" reset="x" width="3" />
        <field access="ru" desc="0: TxRxDiversityOffset0 1: TxRxDiversityOffset1." name="DiversityOffsetSel" offset="31" reset="x" width="1" />
      </reg>
      <reg name="TxFdBerTest" offset="0x0c">
        <field access="rw" desc="Number of symbols of PN-23 data to generate." name="PnNumSyms" offset="0" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="8" reset="x" width="17" />
        <field access="rw" desc="0: LFSR continues at symbol start 1: LFSR set to seed at symbol start." name="PnResetSymStart" offset="25" reset="x" width="1" />
        <field access="rw" desc="0: LFSR continues at packet start 1: LFSR set to seed at packet start." name="PnResetPacketStart" offset="26" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="5" />
      </reg>
      <reg name="TxBinScrambler" offset="0x10">
        <field access="rw" desc="The initial value of the PN-15 LFSR." name="Seed" offset="0" reset="x" width="15" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="1" />
        <field access="rw" desc="The number of symbols to skip (pass through) without scrambling at the start of a packet. Used to skip over the non-data symbols." name="SkipSymCnt" offset="16" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="18" reset="x" width="10" />
        <field access="rw" desc="0: Bin scrambler bypassed 1: Bin scrambler enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxPowerLoad" offset="0x14">
        <field access="rw" desc="Frequency offset in bins. For each subcarrier the index into the selected gain table is the sum (modulo 512) of this and the corresponding bin index. S9 format." name="FreqOffset" offset="0" reset="x" width="9" />
        <field access="ru" name="RESERVED" offset="9" reset="x" width="15" />
        <field access="rw" desc="0: TxPowerLoadGain0 / GainBase0 1: TxPowerLoadGain1 /  GainBase1." name="TableSel" offset="24" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="25" reset="x" width="3" />
        <field access="rw" desc="0: Power load bypassed 1: Power load enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxIQBalPreDistort_0" offset="0x18">
        <field access="ru" name="RESERVED" offset="0" reset="x" width="16" />
        <field access="rw" desc="Number of piecewise linear elements minus 1; 0 implies 1 point, 3 implies 4 points." name="Npnts" offset="16" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="19" reset="x" width="9" />
        <field access="rw" name="SpectralInvEn" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: IQ bal pre-distort bypassed 1: IQ bal pre-distort enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxIQBalPreDistort_1" offset="0x1c">
        <field access="rw" desc="Real part of FIIQ coef." name="Icoef" offset="0" reset="x" width="11" />
        <field access="ru" name="RESERVED" offset="11" reset="x" width="5" />
        <field access="rw" desc="Imaginary part of FIIQ coef estimated by software, format is s&lt;11, -2&gt;." name="Qcoef" offset="16" reset="x" width="11" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="5" />
      </reg>
      <reg name="TxIQBalPreDistort_2" offset="0x20">
        <field access="rw" name="Dbins_2" offset="0" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="8" reset="x" width="8" />
        <field access="rw" desc="Mismatched curve point 3 bin; maximum allowed value is 255." name="Dbins_3" offset="16" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="24" reset="x" width="8" />
      </reg>
      <reg name="TxIQBalPreDistort_3" offset="0x24">
        <field access="rw" name="Dbins_0" offset="0" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="8" reset="x" width="8" />
        <field access="rw" name="Dbins_1" offset="16" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="24" reset="x" width="8" />
      </reg>
      <reg name="TxIQBalPreDistort_4" offset="0x28">
        <field access="rw" name="Dslope_2" offset="0" reset="x" width="11" />
        <field access="ru" name="RESERVED" offset="11" reset="x" width="5" />
        <field access="rw" desc="Mismatched slope3, format is u&lt;11, -6&gt;." name="Dslope_3" offset="16" reset="x" width="11" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="5" />
      </reg>
      <reg name="TxIQBalPreDistort_5" offset="0x2c">
        <field access="rw" name="Dslope_0" offset="0" reset="x" width="11" />
        <field access="ru" name="RESERVED" offset="11" reset="x" width="5" />
        <field access="rw" name="Dslope_1" offset="16" reset="x" width="11" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="5" />
      </reg>
    </regfile>
  </block>
  <block name="PhyTd" offset="0xcc158000">
    <regfile desc="PhyTd Tx Csbuff (dynamic control register)" name="TxCsbCtl" offset="0x0800" absolute_addr="0xcc158800">
      <mult name="0" num="4" offset="0x100" />
      <reg name="TxTdEntryControl" offset="0x00">
        <field access="rw" desc="Writing a '0' transfers this entry to hardware for processing. Writing a '1' transfers this entry to software for reuse." name="Empty" offset="0" reset="1" width="1" />
        <field access="ru" desc="State of corresponding status entry - see TxTdEntryStatus register description." name="StatusEmpty" offset="1" reset="1" width="1" />
        <field access="ru" desc="0: not processed 1: processed Indicates this entry has been processed (but status not necessarily available)." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="1" />
        <field access="ru" desc="How does this happen?." name="ControlUnderflow" offset="4" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="Lost" offset="5" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="Overflow" offset="6" reset="0" width="1" />
        <field access="ru" desc="0: Normal mode. ...1: register mode." name="buff_mode" offset="7" reset="0" width="1" />
        <field access="ru" desc="csbuff control read pointer" name="CtrlRdPtr" offset="8" reset="0" width="4" />
        <field access="ru" desc="csbuff status read pointer" name="StatusWrPtr" offset="12" reset="0" width="4" />
        <field access="rw" desc="Extracted top 16 bits for debug" name="TdTxSwPktType" offset="16" reset="x" width="16" />
      </reg>
      <reg name="TxTdControl" offset="0x04">
        <field access="ru" name="RESERVED" offset="0" reset="x" width="28" />
        <field access="rw" desc="0: normal operation, output I/Q equal to input I/Q ... 1: 12 bits output bits [31:20] for I and bits [15:4] for Q ... 2: 8 bits output bits [31:24] for I and bits [23:16] for Q ... 3: 8 bits output bits [15:8] for I and bits [7:0] for Q ... In bypass modes (TxTdControlMode = 1-3), I/Q outputs are sliced from 32 bits BYPASS input. In those cases, data from FD (assumed as 100Msps rate) is directly output to ASPEN without any processing in this chip. TD transmit section mode. In 10-bit bypass mode 32-bit input data contains a single pair of up to 12-bit I and Q DAC samples. The samples are transferred directly to ASPEN: no processing blocks are active in this chip. 8-bit bypass mode is similar except each 32-bit input data contains two pairs of 8-bit I and Q DAC samples." name="Mode" offset="28" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxIfft_0" offset="0x08">
        <field access="rw" desc="mode to define window size.0-9 for 2,3,4,6,8,12,16,24,48 correspondingly" name="TxWindowMode" offset="0" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="4" reset="x" width="12" />
        <field access="rw" desc="Number of Channel Estimation symbols to output. A value of 0 indicates there is no Channel Estimation input to IFFT. Note the receiver supports at most two CE symbols." name="NumChanEstSyms" offset="16" reset="x" width="4" />
        <field access="rw" desc="Number of Long Sequence segments to output. A value of 0 indicates there is no Long Sequence input to IFFT." name="NumLongSeqSeg" offset="20" reset="x" width="4" />
        <field access="rw" desc="Number of Short Sequence segments to output. A value of 0 indicates there is no Short Sequence input to IFFT." name="NumShortSeqSeg" offset="24" reset="x" width="4" />
        <field access="rw" desc="0: 256-point (MoCA 1.x) 1: 512-point (c.LINK+)." name="Mode" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxIfft_1" offset="0x0c">
        <field access="rw" desc="Gain applied to the long sequence symbol's IFFT output. U&lt;12,1&gt; format." name="LongSeqGain" offset="0" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="12" reset="x" width="4" />
        <field access="rw" desc="Gain applied to the short sequence symbol's IFFT output. U&lt;12,1&gt; format." name="ShortSeqGain" offset="16" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="TxIfft_2" offset="0x10">
        <field access="rw" desc="Gain applied to each data symbols' IFFT output. U&lt;12,1&gt; format." name="DataGain" offset="0" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="12" reset="x" width="4" />
        <field access="rw" desc="Gain applied to the channel estimation symbol's IFFT output. U&lt;12,1&gt; format." name="ChanEstGain" offset="16" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="TxIfft_3" offset="0x14">
        <field access="rw" desc="Length in samples of the cyclic prefix for data symbols.[jm71] A value of 255 indicates a cplength of 512. In RevA silicon. This is restricted to at least 0x40" name="DataCpLength" offset="0" reset="x" width="8" />
        <field access="rw" desc="Length in samples of the cyclic prefix for channel estimation symbols." name="ChanEstCpLength" offset="8" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="TxTdPream" offset="0x18">
        <field access="ru" name="RESERVED" offset="0" reset="x" width="24" />
        <field access="rw" desc="0: don't invert second half 1: invert second half." name="LongSeqInv" offset="24" reset="x" width="1" />
        <field access="rw" desc="0: P1 L3 ... 1: P1 L4 ... 2: P2 FD ... 3: P2 TD + EPP payload ... 4: P3 ... 5: P4 Note for P2 TD + EPP payload the input data is discarded and replaced with the canned EPP payload sequence." name="Select" offset="25" reset="x" width="3" />
        <field access="rw" desc="0: no TD preamble 1: TD preamble enabled Note the TD preamble is only used for MoCA 1.x packets; c.LINK+ preambles are generated in the FD." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxTimingOffResamp" offset="0x1c">
        <field access="rw" desc="Per-sample timing offset. S&lt;14,-9&gt; format." name="SamplingOffset" offset="0" reset="x" width="14" />
        <field access="rw" desc="IQ delay normalized to 200 Mhz sample space, format is S&lt;14,0&gt;." name="IQdelay" offset="14" reset="x" width="14" />
        <field access="rw" desc="0: timing offset resampler disabled 1: timing offset resampler enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxInterp" offset="0x20">
        <field access="rw" desc="0: moca1x mode 1: moca2x mode. used to specify the serdes interface output rate 50M/100M accordingly" name="Mode" offset="0" reset="x" width="1" />
        <field access="rw" desc="0: interpolator 100Mhz -&gt; 200Mhz disabled (up sampled data is equal to input sample) ... 1: interpolator 100Mhz-&gt; 200Mhz enabled " name="Interp2xEnable" offset="1" reset="x" width="1" />
        <field access="rw" desc="if Mode == 1 this bit is ignored, else if Mode ==0, then  ... 0: interpolator 50Mhz -&gt; 100Mhz  disabled (up sampled data is equal to input sample) ... 1: interpolator 50Mhz -&gt; 100Mhz  enabled" name="Interp2xMoca1xEnable" offset="2" reset="x" width="1"></field>
        <field access="rw" name="Interp400Enable" offset="3" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="4" reset="x" width="28" />
      </reg>
      <reg name="TxDigMixer" offset="0x24">
        <field access="rw" desc="U&lt;20,0&gt; format." name="Phase1" offset="0" reset="x" width="20" />
        <field access="ru" name="RESERVED" offset="20" reset="x" width="8" />
        <field access="rw" desc="0: digital mixer bypassed 1: digital mixer enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxOfdmaIqPred" offset="0x028">
        <field access="rw" desc="Q part of compensation coefficients, format s&lt;11,-2&gt;." name="Qcoef" offset="0" reset="x" width="11" />
        <field access="ru" name="RESERVED" offset="11" reset="x" width="6" />
        <field access="rw" desc="I part of compensation coefficients, format s&lt;11, -2&gt;." name="Icoef" offset="17" reset="x" width="11" />
        <field access="rw" name="Enable" offset="28" reset="x" width="1" />
        <field access="rw" desc="0: no inversion, 1: spectrum inversion." name="SpecInvEn" offset="29" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="TxDacIfc_0" offset="0x02c">
        <field access="rw" desc="DAC digital gain mantissa U&lt;9,1&gt; format." name="DigGainMant" offset="0" reset="x" width="9" />
        <field access="ru" name="RESERVED" offset="9" reset="x" width="7" />
        <field access="rw" desc="DAC digital gain exponent. U&lt;2,2&gt; format. This is actually an attenuation, 0 = no attenuation, 1 = 0.5, 2 = 0.25, 3 = 0.125." name="DigGainExp" offset="16" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="18" reset="x" width="10" />
        <field access="rw" desc="0: no inversion 1: inversion When '1' the transmit spectrum is inverted by conjugating the transmit samples." name="InvertSpectrum" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="TxPktGate" offset="0x030">
        <field access="rw" desc="This field is in 50 Mhz precision and format is u&lt;32,32&gt;." name="PktStartTime" offset="0" reset="x" width="32" />
      </reg>
      <reg name="TxTdMisc_0" offset="0x034">
        <field access="rw" desc="0: Moca1x mode. 1: Moca2x mode." name="PktGate_Moca2xMode" offset="0" reset="x" width="1" />
        <field access="rw" desc="offset to ctc_start_time in 100Msamples." name="PcktGatePktStartOffset" offset="1" reset="x" width="14" />
        <field access="rw" desc=". 4 bits input packet ID." name="TxPcktGatePacketId" offset="15" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="19" reset="x" width="13" />
      </reg>
      <reg name="TxEventLogger" offset="0x038">
        <field access="rw" name="RESERVED" offset="0" reset="x" width="4" />
        <field access="rw" desc="1 create event logger pulses for IFFT." name="TxIfftCpiEventLogEn" offset="4" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="5" reset="x" width="27" />
      </reg>
    </regfile>
  </block>
  <block name="PhyDl" offset="0xcc150000">
    <regfile desc="PhyDl Tx Csr Status (static status register)" name="TxCsr" offset="0x0000">
      <reg name="TxDllStatusPlaceholder">
        <field access="ru" name="Placeholder" offset="0" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="1" reset="x" width="31" />
      </reg>
      <reg name="DllStatusCntrl_0">
        <field access="ru" desc="dll fifo status bit 0 - TX FIFO empty ... bit 1 - RX FIFO empty  ...bit 2 - TX FIFO full  ...bit 3 - RX FIFO full" name="PhyFifoStatus" offset="0" reset="0" width="4" />
        <field access="ru" name="RESERVED" offset="4" reset="x" width="28" />
      </reg>
    </regfile>
  </block>
  <block name="PhyFd" offset="0xcc154000">
    <regfile desc="PhyFd Tx Csr Status (static status register)" name="TxCsr" offset="0x0000">
      <reg name="TxFdStatusPlaceholder">
        <field access="ru" name="Placeholder" offset="0" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="1" reset="x" width="31" />
      </reg>
    </regfile>
  </block>
  <block name="PhyTd" offset="0xcc158000">
    <regfile desc="PhyTd Tx Csr Status (static status register)" name="TxCsr" offset="0x0000">
      <reg name="PhyTdStaticStatus">
        <field access="ru" desc=" Fusion2 new add : the number of saturated I/Q data" name="TxAnalogIfcSatCnt" offset="0" reset="x" width="8"></field>
        <field access="ru" name="RESERVED" offset="8" reset="x" width="24" />
      </reg>
    </regfile>
  </block>
  <block name="PhyDl" offset="0xcc150000">
    <regfile desc="PhyDl Tx Csbuff Status (dynamic status register)" name="TxCsbSts" offset="0x0880" absolute_addr="0xcc150880">
      <mult name="0" num="4" offset="0x100" />
      <reg name="TxDllEntryStatus" offset="0x00">
        <field access="rw" desc="Alias - see TxDllEntryControl register description." name="ControlEmpty" offset="0" reset="1" width="1" />
        <field access="rw" desc="Set to '0' by hardware to indicate the entry has valid status. Writing a '1' indicates the entry is transferred to hardware for reuse." name="Empty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Alias - see TxDllEntryControl register description." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="1" />
        <field access="ru" desc="How does this happen?." name="ControlUnderflow" offset="4" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="Lost" offset="5" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="Overflow" offset="6" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="25" />
      </reg>
      <reg name="TxDllStatus" offset="0x04">
        <field access="ru" desc="Set to '1' when the RS encoder is enabled and there are insufficient input data to complete the specified number of blocks." name="RsEncShortPkt" offset="0" reset="x" width="1" />
        <field access="ru" desc="Set to '1' when the RS encoder is enabled and there are more input data than the specified number of blocks." name="RsEncLongPkt" offset="1" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="2" reset="x" width="1" />
        <field access="ru" desc="Set to '1' when the Byte Interleaver is enabled and there are insufficient data to complete the last block." name="ByteInterleaverShortBlock" offset="3" reset="x" width="1" />
        <field access="ru" desc="Set to '1' when the LDPC encoder is enabled and there are insufficient input data to complete the last block." name="LdpcEncShortBlock" offset="4" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="5" reset="x" width="27" />
      </reg>
    </regfile>
  </block>
  <block name="PhyFd" offset="0xcc154000">
    <regfile desc="PhyFd Tx Csbuff Status (dynamic status register)" name="TxCsbSts" offset="0x0880" absolute_addr="0xcc154880">
      <mult name="0" num="4" offset="0x100" />
      <reg name="TxFdEntryStatus" offset="0x00">
        <field access="rw" desc="Alias - see TxFdEntryControl register description." name="ControlEmpty" offset="0" reset="1" width="1" />
        <field access="rw" desc="Set to '0' by hardware to indicate the entry has valid status. Writing a '1' indicates the entry is transferred to hardware for reuse." name="Empty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Alias - see TxFdEntryControl register description." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="1" />
        <field access="ru" name="ControlUnderflow" offset="4" reset="0" width="1" />
        <field access="ru" name="Lost" offset="5" reset="0" width="1" />
        <field access="ru" name="Overflow" offset="6" reset="0" width="1" />
        <field access="ru" desc="0: Normal mode. ...1: register mode." name="buff_mode" offset="7" reset="0" width="1" />
        <field access="ru" desc="csbuff control read pointer" name="CtrlRdPtr" offset="8" reset="0" width="4" />
        <field access="ru" desc="csbuff status read pointer" name="StatusWrPtr" offset="12" reset="0" width="4" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="TxStatusSymbolGen" offset="0x04">
        <field access="ru" desc="Short symbol if insufficient input data to complete OFDM symbol. This bit is set by either the Diversity Assigner or the Bin Assigner, whichever is enabled by TxSymbolGenMode." name="ShortSym" offset="0" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="1" reset="x" width="31" />
      </reg>
    </regfile>
  </block>
  <block name="PhyTd" offset="0xcc158000">
    <regfile desc="PhyTd Tx Csbuff Status (dynamic status register)" name="TxCsbSts" offset="0x0880" absolute_addr="0xcc158880">
      <mult name="0" num="4" offset="0x100" />
      <reg name="TxTdEntryStatus" offset="0x00">
        <field access="rw" desc="Alias - see TxFdEntryControl register description." name="ControlEmpty" offset="0" reset="1" width="1" />
        <field access="rw" desc="Set to '0' by hardware to indicate the entry has valid status. Writing a '1' indicates the entry is transferred to hardware for reuse." name="Empty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Alias - see TxTdEntryControl register description." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="1" />
        <field access="ru" desc="How does this happen?." name="ControlUnderflow" offset="4" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="Lost" offset="5" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="Overflow" offset="6" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="25" />
      </reg>
      <reg name="TxPcktGateStatus" offset="0x04">
        <field access="ru" desc="the period in 50M clocks between the first data arrival time and transmit time." name="PktStartLatency" offset="0" reset="x" width="13" />
        <field access="ru" desc="the number of I or Q positive/negative saturations during the last packets." name="SatCnt" offset="13" reset="x" width="8" />
        <field access="ru" desc="0 : normal ( no error detected ) ... 1 : the parameters for the  packet were ready too late ( i.e. missed the packet ) ... 2 : the packet data arrive     too close to packet        start time supplying       too few inputs in the       FIFO ... 3 : while waiting for FIFO            fill, the packet gate &quot;din_req&quot; has changed. This is a null xmt packet. ... 4 : same as 3 but some data has already been written into the FIFO. Not expecting to get such a case. ... 5 : a gap in the input data during an active packet ( might still be ok if not followed by non zero data ). ... 6 : as in 5 but the gap was followed by non-zero data. ... 7 : the parameters for the   packet were ready way      too early ( too much time to packet start )." name="XmtErr" offset="21" reset="x" width="3" />
        <field access="ru" desc="Status[1] - xmt_fail: whenever xmt_err is not zero during the packet Status[0] - NA." name="XmtStatus" offset="24" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="6" />
      </reg>
      <reg name="TxResampleStatus" offset="0x08">
        <field access="ru" desc="the number of samples inside real data fifo at the end of packet (up to 64)" name="TxResamplerFifoCntI" offset="0" reset="x" width="6" />
        <field access="ru" desc="the number of samples inside real data fifo at the end of packet (up to 64)" name="TxResamplerFifoCntQ" offset="6" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="12" reset="x" width="20" />
      </reg>
    </regfile>
  </block>
  <block name="PhyTd" offset="0xcc158000">
    <regfile desc="PhyTd Rx Csr (static control register)" name="RxCsr" offset="0x0400" absolute_addr="0xcc158400">
      <reg name="PhyRxTdCtrl" offset="0x004">
        <field access="rw" desc="0: Rx TD reset 1: Rx TD enabled." name="Enable" offset="0" reset="0" width="1" />
        <field access="rw" desc="0: &quot;circular queue&quot; mode 1: &quot;register&quot; mode ... Normal operation uses &quot;circular queue&quot; mode. Repetitive and continuous operation use &quot;register&quot; mode." name="DynCtrlMode" offset="1" reset="x" width="1" />
        <field access="rw" desc="special status mode." name="DynStatusMode" offset="2" reset="x" width="1" />
        <field access="rw" desc="RevB and beyond. change name . This is for testing purpose, and should be set to 0." name="RxCtrlClkGateDisCya" offset="3" reset="x" width="1" />
        <field access="rw" desc="0: normal mode ... 1: RepeatMode ... If set to 1, the first packet ReceiveTime is defined by TD Rx Csbuff ReceiveTime parameters, and the rest packets have ReceiveTime equal to the previous packet ReceiveTime plus RxCtrlRepeatDelay." name="RxCtrlRepeatMode" offset="4" reset="x" width="1" />
        <field access="rw" desc="This ignored in non RepeatMode. This defines the size of the IFG (from packet end to next packet start) in RepeatMode. 100Mhz units." name="RxCtrlRepeatDelay" offset="5" reset="x" width="16" />
        <field access="rw" desc="FusionLoopbackMode. ... 0:  normal opperation ... 1:  tx to rx loopback ... 2:  tx to rx loopback but detection gate not based on CTC  " name="FusionLoopbackMode" offset="21" reset="x" width="2" />
        <field access="rw" name="RxMoca1xMclearSimCya" offset="23" reset="x" width="1" />
        <field access="rw" desc="option for the ctrl fsm to ignore &quot;acq_err&quot; or abort on it." name="RxCtrlAcqErrCya" offset="24" reset="x" width="2" />
        <field access="rw" desc="option for short mReset/mClear and option to disable them on forced BurstDetect. This field needs to be set to 10 to enable data rewind in forced burst detect which is needed for Greenfield Beacons and MoCA2 MAP recovery" name="RxCtrlRstClrCya" offset="26" reset="x" width="2" />
        <field access="rw" name="RxCtrlFullResetCya" offset="28" reset="x" width="1" />
        <field access="rw" name="RxSimplePacketCya" offset="29" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxAdcIfc_0" offset="0x08">
        <field access="rw" desc="If the ReceiveTime does not fall within this number of ticks following the current CTC time an invalid receive error is raised. See XXX for details. A value of 0 indicates any ReceiveTime is valid." name="ReceiveTimeValidWindowSize" offset="0" reset="x" width="31" />
        <field access="rw" desc="RevB and beyond. Used to avoid mClear in qeq" name="RxQeqClearCya" offset="31" reset="x" width="1"></field>
      </reg>
      <reg name="RxAdcIfc_1" offset="0x00c">
        <field access="rw" desc="1 : using &quot;rx_ctrl_pkt_stop_time&quot;  0 : ignore the stop time." name="RxCtrlPktStopEnable" offset="0" reset="x" width="1" />
        <field access="rw" desc="0 : align to packet start 1 : use as is Option for software marker transparent mode." name="RxCtrlSoftwareMarkerMode" offset="1" reset="x" width="1" />
        <field access="rw" desc="RevB and beyond. Used to avoid mClear in rotator" name="RxRotatorClearCya" offset="2" reset="x" width="1"></field>
        <field access="rw" desc="RevB and beyond. Used to delay the freq offset input" name="RxRotatorFreqCya" offset="3" reset="x" width="2"></field>
        <field access="rw" desc="RevB and beyond. Used to load early the digital gain if no analog gain adjust is needed" name="AgcDigitalGainFastCya" offset="5" reset="x" width="1"></field>
        <field access="rw" desc="RevB and beyond. Option to load the relative CTC TIME at burst detect." name="RxCtrlDetectCtcCya" offset="6" reset="x" width="1"></field>
        <field access="rw" desc="RevB and beyond. Can calculate the CRC of the I/Q inputs" name="RxRfIfcCrcEnable" offset="7" reset="x" width="1"></field>
        <field access="rw" desc="RevB and beyond. Used to avoid mClear in rf_ifc" name="ClearCya" offset="8" reset="x" width="1"></field>
        <field access="rw" desc="1 : use local sat detection instead of using &quot;a2d_intrp&quot; sat detection" name="AgcSatDetCya" offset="9" reset="x" width="1"></field>
        <field access="ru" name="RESERVED" offset="10" reset="x" width="18"></field>
        <field access="rw" desc="This is CYA signal 0: offset-binary 1: two's complement Specifies format of ADC and loopback inputs (whichever is selected) to Rx TD. The ADC output is offset-binary format. The loopback input format is controlled by TxRfIfc.OutputFormat." name="InputFormat" offset="28" reset="x" width="1" />
        <field access="rw" desc="1 : enable the dc notch." name="DcNotchEnable" offset="29" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxAdcIfc_2" offset="0x010">
        <field access="rw" desc="6 bits gain (32 is unity gain) u&lt;6,1&gt;." name="Gain" offset="0" reset="x" width="6" />
        <field access="rw" desc="option to have 2c I/Q input to the &quot;a2d_intrp&quot; modules 0 =&gt; input is offset binary    1 =&gt; input is 2c" name="RxA2dIntrp_2cCya" offset="6" reset="x" width="1" />
        <field access="rw" desc="option to disable the blanking of I/Q" name="RxA2dIntrpBlankCya" offset="7" reset="x" width="1" />
        <field access="rw" desc="option to control the interpolator phase&#xD;&#xA;" name="RxA2dIntrpPhaseCya" offset="8" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="10" reset="x" width="4" />
        <field access="rw" desc=" SPAR : threshold which |I| &amp; |Q| are compared to declare I/Q sample &quot;sat&quot;" name="AgcSatLavel" offset="14" reset="x" width="9" />
        <field access="rw" desc="dc bias loop bandwidth 0 lowerst loop bandwidth 3 highest loop bandwidth Controls integration period equal to 217-N  samples where N is this value." name="DcBiasCompGainLog2" offset="23" reset="x" width="2" />
        <field access="rw" desc="1 : will clear the static status ( and its error flag )" name="RxCtrlStaticStatusClr" offset="25" reset="x" width="1" />
        <field access="rw" desc=" several options for &quot;rx_a2d_gate&quot;" name="RxCtrlA2dGateCya" offset="26" reset="x" width="4" />
        <field access="rw" desc="This is CYA signal 0: dc bias is in range -64..63 lsb's 1: dc bias is in range  -64..63 lsb's and freeze the dc_bias during blanking 2: dc bias is limited to -32..31 lsb's and freeze the dc_bias during blanking 3: dc bias is limited to -16..15 lsb's and freeze the dc_bias during blanking." name="DcBiasCompMode" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxAdcIfc_3" offset="0x014">
        <field access="rw" desc="BlankingPeriodStart. Blanking period in 200MHz samples following start of receive window. Receiver input is forced to (0,0) during blanking. A value of 0 is no blanking." name="StartBlankWindow" offset="0" reset="x" width="10" />
        <field access="rw" desc="10 bits size of window to blank receiver after &quot;rx_detect_full_reset&quot;." name="ResetBlankWindow" offset="10" reset="x" width="10" />
        <field access="rw" desc="10 bits size of window to blank receiver after &quot;rx_detect_data_clear&quot;." name="ClearBlankWindow" offset="20" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxLowPassFilter" offset="0x018">
        <field access="rw" desc="This is CYA signal disable functionality 0: low pass filter enabled1: low pass filter bypassedFor testing purposes." name="Enable" offset="0" reset="x" width="1" />
        <field access="rw" desc="Reuse . add new simulation option to disabler mClear 0 : normal 1 : don't clear the FIR on &quot;rx_detect_data_clear&quot;." name="ClearCya" offset="1" reset="x" width="1" />
        <field access="rw" desc=": 1:function as 50 MHz lpf, else function according to lpf_moca2x" name="RxLpfAccessMode" offset="2" reset="x" width="1"></field>
        <field access="ru" name="RESERVED" offset="3" reset="x" width="12" />
        <field access="rw" desc=" some options for the new freq offset algorithm&#xD;&#xA;" name="RxFreqOffset2CorrCya" offset="15" reset="x" width="2" />
        <field access="rw" desc="the threshold used by the new algorithm for freq offset&#xD;&#xA;" name="RxFreqOffset2CorrThd" offset="17" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxAgc_0" offset="0x01c">
        <field access="rw" desc="The threshold the absolute value of the received I or Q component must equal or exceed for this sample to count as saturated. U&lt;10,0&gt; format." name="AdcSatThreshold" offset="0" reset="x" width="9" />
        <field access="rw" desc=" RevB and beyond. Option to disable large detection after period without any saturation" name="AgcLargeDetCya" offset="9" reset="x" width="1"></field>
        <field access="rw" desc="the delay before applying an &quot;analog_gain&quot; change as of large detect." name="AgcLargeDetDelay" offset="10" reset="x" width="6" />
        <field access="rw" desc=" RevB and beyond.   Option to change the TD_RX response to mClear ( for easier bit matching )" name="RxMclearSimCya" offset="16" reset="x" width="3"></field>
        <field access="rw" desc="1 : using fixed digital gain." name="AgcFixedDigitalGainCya" offset="19" reset="x" width="1" />
        <field access="rw" desc="the delay before applying an digital_gain&quot; change as of agc_large_detect." name="AgcDigitalGainSseqDelay" offset="20" reset="x" width="8" />
        <field access="rw" desc="maximum number of &quot;agc_sseq_detect&quot;." name="MaxShortSeqDetect" offset="28" reset="x" width="2" />
        <field access="rw" desc=" RevB and beyond. option to replace the &quot;rx_ctrl_pkt_sat_4rd&quot; status" name="RxCtrlStatusCya" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxAgc_1" offset="0x020">
        <field access="rw" desc="the threshold which &quot;analog_energy&quot; is compared to, for &quot;agc_large_detect&quot; is an 8 bit value aligned with &quot;analog_energy&quot; MSB bits ..." name="LargeSigDetEnergyThreshold" offset="0" reset="x" width="8" />
        <field access="rw" desc="max value allowed for the backend gain (0..31 dB)." name="AgcMaxBackendGain" offset="8" reset="x" width="5" />
        <field access="rw" desc="min value allowed for the backend gain (0..31 dB)." name="AgcMinBackendGain" offset="13" reset="x" width="5" />
        <field access="rw" desc="the special iq  level for &quot;agc_analog_energy&quot; (in log2 s&lt;10,5&gt; format)." name="AgcAnalogTargetEnergyIq" offset="18" reset="x" width="10" />
        <field access="rw" desc="cya bits for &quot;agc_digital_gain_sseq_delay&quot; [0] : disable analog_gain  adjust on &quot;agc_sseq_detect&quot; (simulation only) [1] : enable  digital_gain adjust on &quot;agc_sseq_detect&quot; even if analog_gain is not saturated." name="AgcDigitalGainSseqCya" offset="28" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxAgc_2" offset="0x024">
        <field access="rw" desc="U&lt;16,4&gt; format." name="ACorrMin" offset="0" reset="x" width="10" />
        <field access="rw" desc="variations for &quot;agc_force_sseq_detect&quot; mode." name="AgcForceSseqDetectCya" offset="10" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="12" reset="x" width="1" />
        <field access="rw" desc="the max number of sat and large detects combined." name="AgcSatLargeMaxCnt" offset="13" reset="x" width="3" />
        <field access="rw" desc="this is the &quot;agc_sseq_detect&quot; threshold &quot;alpha&quot; (threshold=&quot;digital_energy&quot;*alpha + beta) U&lt;5,1&gt; format. Note this has an extra integer bit compared to the PHY spec for testing purposes." name="ACorrThreshold" offset="16" reset="x" width="4" />
        <field access="rw" desc="the special iq level for &quot;agc_digital_energy (in log2 s&lt;10,5&gt; format)." name="AgcDigitalTargetEnergyIq" offset="20" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxAgc_3" offset="0x028">
        <field access="rw" desc="additional timeout to &quot;agc_sat_timeout_len&quot; upon the first &quot;lseq_peak_detect&quot;." name="AgcPeakDetTimeoutLen" offset="0" reset="x" width="12" />
        <field access="rw" desc="bit by bit matching - 2 way option to select &quot; &quot;analog_gain&quot; &quot; at 100Mhz rate." name="AgcAnalogEnergyTbCya" offset="12" reset="x" width="1" />
        <field access="rw" desc="bit by bit matching - 2 way option to select &quot;agc_sat_detect&quot; at 100Mhz rate." name="AgcSatDetTbCya" offset="13" reset="x" width="1" />
        <field access="rw" desc="duration of no sat/large/agc detect after sat/large detection  ( in en_100's )." name="AgcSatLargeDetDisWindow" offset="14" reset="x" width="12" />
        <field access="rw" desc="option to latch &quot;agc_analog_energy&quot; on &quot;far&quot; peak detections." name="AgcAnalogEnergyLatchCya" offset="26" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="5" />
      </reg>
      <reg name="RxAgc_4" offset="0x02c">
        <field access="rw" desc="The period in 100MHz clocks after AGC Detect to disable Saturation Detect , Large Signal Detect and Agc Detect." name="DisableSatDetPeriodOnAgcDet" offset="0" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="12" reset="x" width="4" />
        <field access="rw" desc="The period in 100MHz clocks after AGC Detect to disable Short Sequence Detect. Note this value is the period in Periodic AGC Mode." name="DisableAgcDetPeriodOnAgcDet" offset="16" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxAgc_5" offset="0x030">
        <field access="rw" desc="duration of no agc detect after sat/large detection            ( in en_100's )." name="AgcSatLargeDetXdisWindow" offset="0" reset="x" width="12" />
        <field access="rw" desc="The number of saturated input samples out of the last 30 that cause a sat1 detect when exceeded." name="SatCntThreshold" offset="12" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="18" reset="x" width="14" />
      </reg>
      <reg name="RxAgc_6" offset="0x034">
        <field access="rw" desc="Maximum final analog gain adjust. The magnitude of a final gain adjust is limited to this maximum value (i.e. clamped to this limit). If the resulting adjustment is within +-2dB the RxAllowFinalGainAdj table controls whether the adjustment is allowed. (Larger adjustment values are implicitly allowed.) In dB." name="MaxFinalAnalogGainAdjust" offset="0" reset="x" width="5" />
        <field access="ru" name="RESERVED" offset="5" reset="x" width="11" />
        <field access="rw" desc="Minimum analog gain. The resulting gain from any gain adjustment is limited to this minimum value (i.e. clamped to this limit) in dB." name="MinAnalogGain" offset="16" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="1" />
        <field access="rw" desc="Maximum analog gain. The resulting gain from any gain adjustment is limited to this maximum value (i.e. clamped to this limit) in dB. the max value allowed for &quot;analog_gain&quot; ( 0..~95 dB." name="MaxAnalogGain" offset="24" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="31" reset="x" width="1" />
      </reg>
      <reg name="RxAgc_7" offset="0x038">
        <field access="rw" desc="Analog gain adjustment in dB applied on large signal detect." name="LargeSignalAnalogGainAdjust" offset="0" reset="x" width="5" />
        <field access="rw" desc="the duration of no agc/sat/large detection after mReset." name="AgcResetDisWindow" offset="5" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="17" reset="x" width="7" />
        <field access="rw" desc="Analog gain adjustment in dB applied on Sat  detect." name="SatAnalogGainAdjust" offset="24" reset="x" width="5" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxAgc_8" offset="0x03c">
        <field access="rw" desc="the main target level for &quot;agc_digital_energy (in log2 s&lt;10,5&gt; format)." name="TargetDigitalEnergy" offset="0" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="10" reset="x" width="4" />
        <field access="rw" desc="The main target level for &quot;agc_analog_energy&quot; (in log2 s&lt;10,5&gt; format)." name="TargetAnalogEnergy" offset="14" reset="x" width="10" />
        <field access="rw" desc="This is CYA signal special modes for bit by bit checking of the agc module agc_simulation_cya[0] - 1 : disable the priority order of : sat_detect &gt; large_detect &gt; sseq_detect (as far as base detection) //  agc_simulation_cya[1] - 1 : disable the blanking interval after detection //  agc_simulation_cya[2] - 1 : disable the clear of &quot;lseq_peak_found&quot; on &quot;large_detect_pend&quot; //  agc_simulation_cya[3] - 1 : disable sat and large detect in fixed gain mode." name="SimulationMode" offset="24" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxFreqOffsetRotator" offset="0x040">
        <field access="rw" desc="option to offset &quot;rewind_time&quot;." name="RxNotchFilterOffset1Cya" offset="0" reset="x" width="4" />
        <field access="rw" desc="option to time offset the contribution of &quot;rx_freq_offset&quot;." name="RxNotchFilterOffset2Cya" offset="4" reset="x" width="4" />
        <field access="rw" desc="option to bypass the rotator if the freq's are zero." name="RxNotchFilterRotCya" offset="8" reset="x" width="1" />
        <field access="rw" desc="option to invert &quot;rewind_time&quot; for &quot;rx_freq_rotator_phase&quot;." name="RxNotchFilterSignCya" offset="9" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="10" reset="x" width="1" />
        <field access="rw" desc="RevB and beyond. Reuse . rx_rf_ifc_clear_cya option to delay mClear by 1 clk." name="RxNotchFilterClearCya" offset="11" reset="x" width="1"></field>
        <field access="rw" name="RESERVED" offset="12" reset="x" width="20" />
      </reg>
      <reg name="RxResampler" offset="0x044">
        <field access="rw" desc="rx_resampler_buffer_cya  = rx_resampler_sim_cya[1:0]; resampler_offset_en_cya  = rx_resampler_sim_cya[3:2]; resampler_offset_dly_cya = rx_resampler_sim_cya[4];. Fusion2." name="BufferCya" offset="0" reset="x" width="8"></field>
        <field access="rw" desc="RevB and beyond. Used to avoid mClear in resampler." name="ClearCya" offset="8" reset="x" width="1"></field>
        <field access="ru" name="RESERVED" offset="9" reset="x" width="24" />
      </reg>
      <reg name="RxNotchFilters_0" offset="0x048">
        <field access="rw" desc="FS1. U&lt;14,0&gt; format." name="Notch1Coeff0_2" offset="0" reset="x" width="14" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="FS1. S&lt;16,2&gt; format." name="Notch1Coeff0_1" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxNotchFilters_1" offset="0x04c">
        <field access="rw" desc="FS3.U&lt;14,0&gt; format." name="Notch1Coeff1_02" offset="0" reset="x" width="14" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="FS3. S&lt;16,2&gt; format." name="Notch1Coeff1_01" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxNotchFilters_2" offset="0x050">
        <field access="rw" desc="FS2. S&lt;15,1&gt; format." name="Notch1Coeff1_11" offset="0" reset="x" width="15" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="17" />
      </reg>
      <reg name="RxNotchFilters_3" offset="0x054">
        <field access="rw" desc="FS1. U&lt;14,0&gt; format." name="Notch2Coeff0_2" offset="0" reset="x" width="14" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="FS1. S&lt;16,2&gt; format." name="Notch2Coeff0_1" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxNotchFilters_4" offset="0x058">
        <field access="rw" desc="FS3.U&lt;14,0&gt; format." name="Notch2Coeff1_02" offset="0" reset="x" width="14" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="2" />
        <field access="rw" desc="FS3. S&lt;16,2&gt; format." name="Notch2Coeff1_01" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxNotchFilters_5" offset="0x05c">
        <field access="rw" desc="FS2. S&lt;15,1&gt; format." name="Notch2Coeff1_11" offset="0" reset="x" width="15" />
        <field access="rw" desc="rx csr spare" name="RxCsrSpare" offset="15" reset="x" width="8" />
        <field access="ru" desc="Rx Csr status" name="RxCsrStatus" offset="23" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="31" reset="x" width="1" />
      </reg>
      <reg name="RxBurstAcq_0" offset="0x060">
        <field access="rw" desc="several cya options for forced mode." name="LseqForceFinalDetectCya" offset="0" reset="x" width="3" />
        <field access="rw" desc="the number of samples for packet mean time calcualtion ( &quot;M&quot; )." name="LseqMeanCalcWindow" offset="3" reset="x" width="7" />
        <field access="rw" desc="the max value of &quot;lseq_peak_to_mean&quot;." name="LseqPeakToMeanMax" offset="10" reset="x" width="7" />
        <field access="rw" desc="peak detection timeout after &quot;rx_detect_data_clear&quot;." name="LargeGainAdjDisableTime" offset="17" reset="x" width="8" />
        <field access="rw" desc="option to modify the effective value of &quot;lseq_corr_gap_window&quot;. This value would be supplied by system group after further experiments." name="LseqCorrGapWindowCya" offset="25" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxDigGain" offset="0x064">
        <field access="rw" desc="the max difference of OFDM start." name="OfdmStartThdEventp" offset="0" reset="x" width="12" />
        <field access="rw" desc="expected OFDM start after gate open." name="OfdmExpStartEventp" offset="12" reset="x" width="12" />
        <field access="rw" desc="enable unity gain of 32 and fixed gain of 8." name="Cya" offset="24" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="6" />
      </reg>
      <reg name="RxOfdmSymFramer" offset="0x068">
        <field access="rw" desc="RevB and beyond. change names .  cya bits! agc_sseq_detect_cnt_clr_cya  " name="AgcSseqDetectCntClrCya" offset="0" reset="x" width="1" />
        <field access="rw" desc="RevB and beyond. change names .  cya bits!    agc_sat_large_latch_cya   " name="AgcSatLargeLatchCya" offset="1" reset="x" width="1" />
        <field access="rw" desc="RevB and beyond. change names .   Cya bits!   agc_energy_peak_delay_cya[1:0]" name="AgcEnergyPeakDelayCya" offset="2" reset="x" width="2"></field>
        <field access="ru" name="RESERVED" offset="4" reset="x" width="1" />
        <field access="rw" desc="adc to FFT hardware pipeline delay (not including &quot;rot_notch&quot; pipeline delay!)." name="RxAdc2FftPipelineDelay" offset="5" reset="x" width="5" />
        <field access="rw" desc="&quot;freq_rot&quot; to &quot;framing&quot; delay." name="RxFreqRotToFramingDelay" offset="10" reset="x" width="2" />
        <field access="rw" name="RESERVED" offset="12" reset="x" width="3" />
        <field access="rw" desc="enable time window for the second CE." name="RxTimeWindowCeCya" offset="15" reset="x" width="2" />
        <field access="rw" desc="When '1' the last data symbol in the received packet is not sent to the FFT. This is used when necessary to provide time for the EPP IFFT." name="DiscardLastDataSym" offset="17" reset="x" width="4" />
        <field access="rw" desc="enable time window for the second CE." name="RxRfIfcPacketEndCya" offset="21" reset="x" width="1" />
        <field access="rw" desc="bias to &quot;lseq_final_mean_to_fft&quot; to be compatible with RTL." name="RxMeanToFftBiasCya" offset="22" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="6" />
      </reg>
      <reg name="RxFreqOffsetEst_0" offset="0x06c">
        <field access="rw" desc="Ratio of sampling frequency (100 MHz) to carrier frequency. U&lt;12,1&gt; format." name="RfVal" offset="0" reset="x" width="16" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="1" />
        <field access="rw" desc="The offset to apply to &quot;rx_ce_analog_energy_delay&quot; (for easy bit matching!) Ce_energy unit." name="RxCeAnalogOffsetCya" offset="17" reset="x" width="3" />
        <field access="rw" desc="max value of agc analog gain adjust." name="RxAgcAdjustThdEventp" offset="20" reset="x" width="5" />
        <field access="rw" desc="max value of final analog gain adjust." name="RxFinalAdjustThdEventp" offset="25" reset="x" width="5" />
        <field access="rw" desc="This is CYA signal Mode[0] =1  cya option to force using the last peak when in the special &quot;invert_dummy&quot; mode. Mode[1] =1  cya option to force using the last peak all the time." name="Mode" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxFreqOffsetEst_1" offset="0x070">
        <field access="rw" desc="Moca2x conversion constant from freq offset to time ppm offset." name="RfValMoca2" offset="0" reset="x" width="16" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxEventLog_0" offset="0x074">
        <field access="rw" desc="target (expected) value of the freq offset." name="FreqOffsetTargetEventp" offset="0" reset="x" width="16" />
        <field access="rw" desc="max value for the &quot;rf_ifc&quot; dc bias." name="RxMaxBiasEventp" offset="16" reset="x" width="8" />
        <field access="rw" name="RxSatThdEventp" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RxEventLog_1" offset="0x078">
        <field access="rw" desc="the max difference to the target freq offset." name="FreqOffsetThdEventp" offset="0" reset="x" width="15" />
        <field access="rw" desc="the threshold for the time window &quot;delta&quot; values." name="TimeWindDeltaThdEventp" offset="15" reset="x" width="13" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxEventLog_2" offset="0x07c">
        <field access="rw" desc="the min value for the CE digital energy event." name="DigitalEnergyMinEventp" offset="0" reset="x" width="16" />
        <field access="rw" desc="the max value for the CE digital energy event." name="DigitalEnergyMaxEventp" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxEventLog_3" offset="0x080">
        <field access="rw" desc="the min value for the CE analog  energy event." name="AnalogEnergyMinEventp" offset="0" reset="x" width="16" />
        <field access="rw" desc="the max value for the CE analog  energy event." name="AnalogEnergyMaxEventp" offset="16" reset="x" width="16" />
      </reg>
      <reg name="FastAgcCtrl" offset="0x084">
        <field access="ru" name="RESERVED" offset="0" reset="x" width="4" />
        <field access="rw" name="FastAgcDataMsb" desc="FastAGC data bit 15:5. Should set to 1110 for Eldora. Five LSBs are from output of LOG_GAIN table" offset="5" reset="x" width="11" name_color="r" />
        <field access="rw" name="FastAgcNumBit" desc="Number of Fast AGC message bits. Max value is 16. Should set to 9 for Eldora" offset="16" reset="x" width="5" name_color="r"></field>
        <field access="ru" name="RESERVED" offset="21" reset="x" width="11" />
      </reg>
      <reg name="PhyRxCntrl_88" offset="0x088">
        <field access="rw" desc="option to open loops for bit by bit matching" name="RxOpenLoopCya" offset="0" reset="x" width="8" />
        <field access="rw" desc="option for bit by bit matching" name="RxBitMatchCya" offset="8" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
    </regfile>
  </block>
  <block name="PhyFd" offset="0xcc154000">
    <regfile desc="PhyFd Rx Csr (static control register)" name="RxCsr" offset="0x0400" absolute_addr="0xcc154400">
      <reg name="PhyRxFdCtrl" offset="0x004">
        <field access="rw" desc="0: Rx FD reset 1: Rx FD enabled." name="Enable" offset="0" reset="0" width="1" />
        <field access="rw" desc="0: &quot;circular queue&quot; mode 1: &quot;register&quot; mode ... Normal operation uses &quot;circular queue&quot; mode. Repetitive and continuous operation use &quot;register&quot; mode." name="DynCtrlMode" offset="1" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="2" reset="x" width="21" />
        <field access="rw" desc="This field is for testing purpose and should be set to 0." name="Fpga_td_board2board_mode" offset="23" reset="x" width="4" />
        <field access="rw" desc="This field is for testing purpose and should be set to 0." name="Fpga_td_board2board_en" offset="27" reset="x" width="1" />
        <field access="rw" desc="This fiel dis for testing purpose and should be set to 0." name="Fpga_options" offset="28" reset="x" width="2" />
        <field access="rw" desc="This field is for testing purpose and should be set to 0." name="Fpga_loopback_sel" offset="30" reset="x" width="1" />
        <field access="rw" desc="This field is for testing purpose and should be set to 0." name="fpga_test_output_sel" offset="31" reset="x" width="1" />
      </reg>
      <reg name="RxChanComp_0" offset="0x008">
        <field access="rw" desc="0: 1 taps ... 1: 3 taps ... 2: 5 taps ... 3: 7 taps ... 4: 9 taps ... 5: 15 taps ... 6: 23 taps ... 7: 29 taps ... 8: 35 taps ... 9: 51 taps ... If the number of available taps is &lt; ChanEstSmoothMinFilter, then filter length of 1 is used. Setting this value to 0 to disable ChanEstSmoothMinFilter decision." name="ChanEstSmoothMinFilter" offset="0" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="4" reset="x" width="28" />
      </reg>
      <reg name="RxFreqTrack" offset="0x00c">
        <field access="rw" desc="Chooses which ContexTID the tranckingIntegral value would be returned to status queue." name="IntegralStatusContextID" offset="0" reset="x" width="3" />
        <field access="rw" desc="Error threshold to ensure very noisy constellations do not contribute to phase error averaging. Format is u&lt;6,0&gt;. This field applied to both Freq and Time track loop." name="maxError" offset="3" reset="x" width="6" />
        <field access="rw" desc="Phase detector control. Format is u&lt;14, 14&gt;, valid range is 0-8320 decimal." name="FcToBinBWRatio" offset="9" reset="x" width="14" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="9" />
      </reg>
      <reg name="RxTimeTrack" offset="0x010">
        <field access="rw" desc="Chooses which ContexTID the tranckingIntegral value would be returned to status queue." name="IntegralStatusContextID" offset="0" reset="x" width="3" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="29" />
      </reg>
      <reg name="RxNve_0" offset="0x014">
        <field access="rw" desc="Format U&lt;4,4&gt;." name="NveIntfLevel3" offset="0" reset="x" width="4" />
        <field access="rw" desc="Format U&lt;4,4&gt;." name="NveIntfLevel2" offset="4" reset="x" width="4" />
        <field access="rw" desc="Format U&lt;4,4&gt;." name="NveIntfLevel1" offset="8" reset="x" width="4" />
        <field access="rw" desc="Format U&lt;5,5&gt;, DATA symbol interference &gt; thresh for event detect and status." name="NveDatIntfDetThresh" offset="12" reset="x" width="5" />
        <field access="rw" desc="Format U&lt;2,2&gt;, CE symbol interference &gt; thresh for event detect." name="NveCesIntfDetThresh" offset="17" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="19" reset="x" width="5" />
        <field access="rw" desc="Format U&lt;4,4&gt;, see PHY Functional Spec for description." name="NveEvmMinFactor" offset="24" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxNve_1" offset="0x018">
        <field access="rw" desc="Format U&lt;5,5&gt;." name="NveFastLoopThrNeg" offset="0" reset="x" width="5" />
        <field access="rw" desc="Format U&lt;5,5&gt;." name="NveFastLoopThrPos" offset="5" reset="x" width="5" />
        <field access="ru" name="RESERVED" offset="10" reset="x" width="6" />
        <field access="rw" desc="Format U&lt;3,3&gt;." name="NveSlowLoopAttNeg" offset="16" reset="x" width="3" />
        <field access="rw" desc="Format U&lt;3,3&gt;." name="NveSlowLoopAttPos" offset="19" reset="x" width="3" />
        <field access="rw" desc="Format U&lt;3,3&gt;." name="NveFastLoopAttNeg" offset="22" reset="x" width="3" />
        <field access="rw" desc="Format U&lt;3,3&gt;." name="NveFastLoopAttPos" offset="25" reset="x" width="3" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxNve_2" offset="0x01c">
        <field access="rw" desc="Format U&lt;9,5&gt;." name="NveStaticTmValue" offset="0" reset="x" width="9" />
        <field access="rw" name="NveStaticTm" offset="9" reset="x" width="1" />
        <field access="rw" name="NveVarEstMode" offset="10" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="11" reset="x" width="21" />
      </reg>
      <reg name="RxFdBerTest_0" offset="0x020">
        <field access="rw" desc="The initial value of the PN-23 LFSR at packet and/or symbol boundaries as controlled by PnResetPacketStart and PnResetSymStart." name="PnSeed" offset="0" reset="x" width="23" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="4" />
        <field access="rw" desc="When '0' and set to '1' the internal PnResetPacketStartOnce bit is set to '1'. The internal PnResetPacketStartOnce bit is identical in function to the PnResetPacketStart bit, except it is cleared to '0' following a packet with FD Bert check enabled and hence only applies to a single packet." name="SetPnResetPacketStartOnce" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: bin 1: constellation ... 2: symbol ... 'symbol' mode collects statistics for every active (non-NULL constellation) bin over the specified data symbols in the packet. The specified symbols are those whose indices match Index under the IndexMask. Symbol indices are sequential from 0 starting from the first data symbol. Note that setting IndexMask to 0 will collect statistics over all data symbols in the packet. 'bin' mode collects statistics for the specified active (non-NULL constellation) bins over all data symbols in the packet. The specified bins are those whose indices match Index under the IndexMask. 'constellation' mode collects statistics for the specified active (non-NULL constellation) bins over all data symbols in the packet. The specified bins are those whose bitloading matches Index[3:0] under the IndexMask. In all modes statistics are only collected on bins associated with ContextID in addition to the mode-specific bin selection criteria." name="Mode" offset="28" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxFdBerTest_1" offset="0x024">
        <field access="rw" desc="Specifies bins or symbols or constellations (depending on mode) to collect statistics for. A masked comparison (see IndexMask for details) to Index is used." name="Index" offset="0" reset="x" width="9" />
        <field access="ru" name="RESERVED" offset="9" reset="x" width="7" />
        <field access="rw" desc="Masks bits of the difference vector (bit vector of differences) between Index and bin index or symbol index or bitloading value (depending on mode). Each '1' in IndexMask indicates the corresponding bit in the difference vector is significant and will cause a mismatch if true." name="IndexMask" offset="16" reset="x" width="9" />
        <field access="ru" name="RESERVED" offset="25" reset="x" width="7" />
      </reg>
      <reg name="RxFdBerTest_2" offset="0x028">
        <field access="rw" desc="Number of checked received packets since the last refresh (or reset) after which the status registers should be refreshed. See Refresh bit above." name="RefreshNumPkts" offset="0" reset="x" width="16" />
        <field access="rw" desc="When '0' and set to '1' a refresh of the status registers will be performed when at least RefreshNumPkts have been received following the last refresh. If RefreshNumPkts is 0 the status registers will be refreshed immediately. If a cumulative count MSB becomes '1' before RefreshNumPkts have been received the refresh is performed at that point instead." name="Refresh" offset="16" reset="0" width="1" />
        <field access="rw" desc="When '0' and set to '1' the StatusRefreshed bit is cleared to '0'." name="ClearStatusRefreshed" offset="17" reset="0" width="1" />
        <field access="ru" desc="Set to '1' after the status registers have been refreshed. Refreshing the status registers copies the cumulative count values to the status registers and then clears the cumulative counts. The status registers are refreshed in response to setting the Refresh bit (see below) or when the MSB of any cumulative count becomes '1'. This bit should be cleared via the ClearStatusRefreshed bit to be able to determine when the next refresh occurs. Hardware has a two clocks latency to reflect StatusRefreshed after ClearStatusRefresh. Thus software should not read back the StatusRefreshed immediately." name="StatusRefreshed" offset="18" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="19" reset="x" width="13" />
      </reg>
      <reg name="RxFreqTimeRot" offset="0x02c">
        <field access="rw" desc="Number of Symbols would be CPE rotated. If this field is set to 0xf, all symbols would be rotated." name="NumCPECorrectSym" offset="0" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="4" reset="x" width="28" />
      </reg>
      <reg name="RxSlicerAGC" offset="0x030">
        <field access="rw" desc="Number of symbols used to update the Zip2 detector." name="NumZip2Symbols" offset="0" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="4" reset="x" width="28" />
      </reg>
      <reg name="RxFDEventThresh0" offset="0x034">
        <field access="rw" desc="Event is generated for the selected OFDMA context (as indicated by statusContextID of event logger) if abs(cpeEst) is greater than or equal to cpeRangeThresh. Format is u&lt;11,0&gt;." name="cpeRangeThresh" offset="0" reset="x" width="11" />
        <field access="ru" name="RESERVED" offset="11" reset="x" width="5" />
        <field access="rw" desc="The field selects whichof the cpeEstRange, freqTrackRange and timeTrackRange values to use to trigger the events. There are 8 sets of values each corresponding to a context ID." name="fttEventContextId" offset="16" reset="x" width="3" />
        <field access="ru" name="RESERVED" offset="19" reset="x" width="13" />
      </reg>
      <reg name="RxFDEventThresh1" offset="0x038">
        <field access="rw" desc="Event is generated for the selected OFDMA context (as indicated by statusContextID of event logger) if abs(timeEst) is greater than or equal to timeEstRangeThresh. Format is u&lt;13,0&gt;." name="timeEstRangeThresh" offset="0" reset="x" width="13" />
        <field access="ru" name="RESERVED" offset="13" reset="x" width="3" />
        <field access="rw" desc="Event is generated for the selected OFDMA context (as indicated by statusContextID of event logger) if abs(freqEst) is greater than or equal to freqEstRangeThresh. Format is u&lt;13,0&gt;." name="freqEstRangeThresh" offset="16" reset="x" width="13" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxFDEventThresh2" offset="0x03c">
        <field access="rw" desc="Event is generated for any packet where the bit error counter exceeds fdBertErrThresh." name="fdBertErrThresh" offset="0" reset="x" width="16" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="8" />
        <field access="rw" desc="Event is generated when abs(slicerAgc - 1.0) is greater than or equal to this field. The format is u&lt;8,-3&gt;." name="slicerAgcRange" offset="24" reset="x" width="8" />
      </reg>
    </regfile>
  </block>
  <block name="PhyDl" offset="0xcc150000">
    <regfile desc="PhyDl Rx Csr (static control register)" name="RxCsr" offset="0x0400" absolute_addr="0xcc150400">
      <reg name="PhyRxDllCtrl" offset="0x004">
        <field access="rw" desc="0: Rx DLL reset 1: Rx DLL enabled." name="Enable" offset="0" reset="0" width="1" />
        <field access="rw" desc="0: &quot;circular queue&quot; mode 1: &quot;register&quot; mode ... Normal operation uses &quot;circular queue&quot; mode. Repetitive and continuous operation use &quot;register&quot; mode." name="DynCtrlMode" offset="1" reset="x" width="1" />
        <field access="rw" desc="0: normal operation 1: loopback Rx DLL to Tx DLL Note this bit controls both Tx and Rx and the loopback is from the perspective of an external transmitter." name="LoopbackToTx" offset="2" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="29" />
      </reg>
      <reg name="RxLdpcDec" offset="0x008">
        <field access="rw" desc="0: 1.0 ... 1: 0.875 ... 2: 0.8125 ... 3: 0.75 ... 4: 0.6875 ... 5. 0.625 ... Selects the prescale factor used when CodeSel is 0 (4608 rate 19/24 code). (CodeSel is either RxLdpcDec.InitialCodeSel or RxLdpcDec.FinalCodeSel, whichever is active)." name="CodeSel0PrescaleSel" offset="0" reset="x" width="3" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="1" />
        <field access="rw" desc="0: 1.0 ... 1: 0.875 ... 2: 0.8125 ... 3: 0.75 ... 4: 0.6875 ... 5. 0.625 ... Selects the prescale factor used when CodeSel is 1 (576 rate 3/4 (OFDMA) code). (CodeSel is either RxLdpcDec.InitialCodeSel or RxLdpcDec.FinalCodeSel, whichever is active)." name="CodeSel1PrescaleSel" offset="4" reset="x" width="3" />
        <field access="rw" desc="0: Abort decode on input buffer full ... 1: Decode ignores input buffer full ... When '1' the decoder won't abort decoding the current block set when the input buffer is full - it only stops decoding when either the early stop condition is met (and EarlyStopEnable is '1') or the corresponding MaxIters iteration limit is reached. This is intended for use in loopback testing of the LDPC decoder where flow control ensures no data is lost. When '0' the decoder aborts decoding the current block set when the input buffer is full to avoid data loss. Must be '0' for normal operation." name="InBuffFullAbortDisable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="25" />
      </reg>
      <reg name="RxDataPattCheck_0" offset="0x00c">
        <field access="rw" desc="When the PN23 or PN23 Serial patterns are selected InitialPatternState[22:0] is the initial (seed) value of the PN-23 LFSR. Note InitialPatternState[0] is the first bit shifted out of the LFSR; this is consistent with the bit order of the Byte Scrambler LFSR seed but bit-reversed compared to the definition of this parameter in the PHY Systems spec. When the RAMP pattern is selected InitialPatternState[7:0] is the starting value of the ramp. When the TWO-BYTE pattern is selected InitialPatternState[7:0] followed by InitialPatternState[15:8] are the repeating pattern." name="InitialPatternState" offset="0" reset="x" width="23" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="4" />
        <field access="rw" desc="When '0' and set to '1' the internal PattResetPacketStartOnce bit is set to '1'. The internal PattResetPacketStartOnce bit is identical in function to the PattResetPacketStart bit, except it is cleared to '0' following a checked packet and hence only applies to a single packet." name="SetPattResetPacketStartOnce" offset="27" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxDataPattCheck_1" offset="0x010">
        <field access="rw" desc="Number of checked received packets since the last refresh (or reset) after which the status registers should be refreshed. See Refresh bit above." name="RefreshNumPkts" offset="0" reset="x" width="16" />
        <field access="rw" desc="When '0' and set to '1' a refresh of the status registers will be performed when at least RefreshNumPkts have been received following the last refresh. If RefreshNumPkts is 0 the status registers will be refreshed immediately. If a cumulative count MSB becomes '1' before RefreshNumPkts have been received the refresh is performed at that point instead." name="Refresh" offset="16" reset="0" width="1" />
        <field access="rw" desc="When '0' and set to '1' the StatusRefreshed bit is cleared to '0'." name="ClearStatusRefreshed" offset="17" reset="0" width="1" />
        <field access="ru" desc="Set to '1' after the status registers have been refreshed. Refreshing the status registers copies the cumulative count values to the status registers and then clears the cumulative counts. The status registers are refreshed in response to setting the Refresh bit (see below) or when the MSB of any cumulative count becomes '1'. This bit should be cleared via the ClearStatusRefreshed bit to be able to determine when the next refresh occurs." name="StatusRefreshed" offset="18" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="19" reset="x" width="1" />
        <field access="rw" desc="0: 1/2 ... 1: 1/4 ... 2: 1/8 ... 3: 1/16 ... The BER which if exceeded classifies the packet as an outlier. Outlier packets do not update the cumulative counts (except for the NumOutlierPackets count). When the PN23 pattern is selected outlier packets cause the pattern generator to attempt re-synchronization on the next packet checked (unless either PattResetPacketStartOnce or PattResetPacketStart is '1' for the next checked packet)." name="OutlierThreshold" offset="20" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="10" />
      </reg>
      <reg name="RxDLLEventThresh0" offset="0x014">
        <field access="rw" desc="Event is generated if RS decoder number of corrected bytes is greater than or equal to this field." name="rsCorrByteLargeThresh" offset="0" reset="x" width="4" />
        <field access="rw" desc="Event is generated if number of LDPC decLayerCnt exceeds this threshold for long codes." name="ldpcItnLargeLongThresh" offset="4" reset="x" width="8" />
        <field access="rw" desc="Event is generated if number of LDPC decLayerCnt exceeds this threshold for short codes." name="ldpcItnLargeShortThresh" offset="12" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="20" reset="x" width="12" />
      </reg>
    </regfile>
  </block>
  <block name="PhyTd" offset="0xcc158000">
    <regfile desc="PhyTd Rx Csbuff (dynamic control register)" name="RxCsbCtl" offset="0x1000" absolute_addr="0xcc159000">
      <mult name="0" num="4" offset="0x100" />
      <reg name="RxTdEntryControl" offset="0x00">
        <field access="rw" desc="Writing a '0' transfers this entry to hardware for processing. Writing a '1' transfers this entry to software for reuse." name="Empty" offset="0" reset="1" width="1" />
        <field access="ru" desc="State of corresponding status entry - see TxEntryNStatus register description." name="StatusEmpty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Indicates this entry has been processed (but status not necessarily available). 0: not processed 1: processed." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="1" />
        <field access="ru" desc="How does this happen?." name="RxTdControlUnderflow" offset="4" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="RxTdStatusLost" offset="5" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="RxTdStatusOverflow" offset="6" reset="0" width="1" />
        <field access="ru" desc="0: Normal mode. ...1: register mode." name="buff_mode" offset="7" reset="0" width="1" />
        <field access="ru" desc="csbuff control read pointer" name="CtrlRdPtr" offset="8" reset="0" width="4" />
        <field access="ru" desc="csbuff status read pointer" name="StatusWrPtr" offset="12" reset="0" width="4" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxAdcIfc_0" offset="0x04">
        <field access="rw" desc="CTC time at which the receive window should open. The first ADC sample is accepted when the current CTC time is equal to or greater than this time. See CTC Times for further details. This field is in 50 Mhz precision and format is u&lt;32,32&gt;." name="ReceiveTime" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxAdcIfc_1" offset="0x08">
        <field access="rw" desc="Number of CTC ticks the receive window should remain open." name="ReceiveWindowSize" offset="0" reset="x" width="31" />
        <field access="ru" name="RESERVED" offset="31" reset="x" width="1"></field>
      </reg>
      <reg name="RxAdcIfc_2" offset="0x0c">
        <field access="ru" name="RESERVED" offset="0" reset="x" width="5" />
        <field access="rw" desc="used as marker for the test_mux." name="RxCtrlSoftwareMarker" offset="5" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="6" reset="x" width="1" />
        <field access="rw" desc="0: no inversion ... 1: inversion ... When '1' the receive spectrum is inverted by conjugating the received samples." name="InvertSpectrum" offset="7" reset="x" width="1" />
        <field access="rw" name="RxCtrlPktStartOffset" offset="8" reset="x" width="14" />
        <field access="rw" desc="0: normal mode ... 1: re-center after bias change ... 2: loop BW to 0 during OFDM ... 3: freeze during OFDM." name="DcBiasCompCya" offset="22" reset="x" width="2" />
        <field access="rw" desc="Test only, set this field to 0." name="BlankingSatCya" offset="24" reset="x" width="2" />
        <field access="rw" desc="0: DC bias estimation continues from current value at packet start ... 1: DC bias estimation reset at start of packet." name="DcBiasCompResetPacketStart" offset="26" reset="x" width="1" />
        <field access="rw" desc="enable mClear." name="RxCtrlPktClearEnable" offset="27" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="31" reset="x" width="1" />
      </reg>
      <reg name="RxMoca1xShiftRotator" offset="0x10">
        <field access="rw" desc="Rotation frequency, format s&lt;21,-1&gt;." name="rotFreq" offset="0" reset="x" width="21" />
        <field access="ru" name="RESERVED" offset="21" reset="x" width="6" />
        <field access="rw" desc="0: freqOffset not added. 1: Add freqOffset into the accumulator." name="useFreqOff" offset="27" reset="x" width="1" />
        <field access="rw" desc="option to bypass completely this rotator (when 0) enable the moca1x rotator." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxResamplerLpf" offset="0x14">
        <field access="rw" desc="the 2c delta delay of Q relative to I Format is s&lt;14,0&gt;." name="IqDelay" offset="0" reset="x" width="14" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="13" />
        <field access="rw" desc="0: 25 MHz (MoCA 1.x) 1: 50 MHz (c.LINK+)." name="Mode" offset="27" reset="x" width="1" />
        <field access="rw" desc="This is CYA signal the resampler is disabled if this field is set to 1; For normal operation, set this field to 0" name="EnableResample" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxAgc_0" offset="0x18">
        <field access="rw" desc="the initial value for &quot;digital_gain&quot;  In dB  U&lt;8,6&gt; format." name="InitialDigitalGain" offset="0" reset="x" width="9" />
        <field access="rw" desc="the initial value for &quot;analog_gain&quot;  In dB." name="InitialAnalogGain" offset="9" reset="x" width="7" />
        <field access="rw" desc="0: maxAnalogGain 1: initialAnalogGain 2: unchanged (i.e. hold current gain)." name="AnalogGainSettingOnReset" offset="16" reset="x" width="2" />
        <field access="rw" desc="When '1' the AGC is reset on ACQ Error." name="ResetOnAcqError" offset="18" reset="x" width="1" />
        <field access="rw" desc="When '1' the AGC is reset on Saturation Timeout or False Alarm errors." name="ResetOnAgcError" offset="19" reset="x" width="1" />
        <field access="rw" desc="1 : enable final gain adjust (for digital and possible also analog)." name="AgcFinalGainEn" offset="20" reset="x" width="1" />
        <field access="rw" desc="1 : using  fixed analog and digital gain." name="AgcFixedGainMode" offset="21" reset="x" width="1" />
        <field access="rw" desc="1 : enable analog  gain correction on &quot;lseq_final_detect&quot;." name="AgcAnalogGainFinalEn" offset="22" reset="x" width="1" />
        <field access="rw" desc="1 : enable digital gain adjust on &quot;agc_sseq_detect&quot;." name="AgcDigitalGainSseqEn" offset="23" reset="x" width="1" />
        <field access="rw" desc="1 : disable AGC sat_detect and large_detect See disableLargerGainAdjustments in PHY Functional Spec." name="AgcSatLargeDetDisable" offset="24" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="25" reset="x" width="2" />
        <field access="rw" desc="1 : a mode in which a dummy &quot;agc_sseq_detect&quot; are generated at programmble rate." name="PeriodicMode" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: window = 120/60 (MoCA 1.x) 1: window = 128/64 (c.LINK+) Controls window sizes of analog and digital energy estimators and the short sequence correlator." name="Mode" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxAgc_1" offset="0x1c">
        <field access="rw" desc="the duration of no more &quot;agc_sseq_detect&quot; after mReset." name="DisableAgcDetPeriodOnReset" offset="0" reset="x" width="12" />
        <field access="rw" desc="If set then only backend gain is changed for analgoGainAdjustments." name="ChangeOnlyBackendGain" offset="12" reset="x" width="1" />
        <field access="rw" desc="1 : select &quot;agc_xxx_target_energy_iq&quot; instead of &quot;agc_xxx_target_energy&quot;." name="AgcTargetEnergyIqSel" offset="13" reset="x" width="1" />
        <field access="rw" desc="variations for &quot;agc_force_sseq_detect&quot; mode." name="AgcForceSseqDetect" offset="14" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="17" />
      </reg>
      <reg name="RxAgc_2" offset="0x20">
        <field access="rw" desc="Maximum delay in 100MHz clocks from an AGC Detect to a Burst Detect. If this delay is exceeded a False Alarm Timeout is declared." name="FalseAlarmTimeoutPeriod" offset="0" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="12" reset="x" width="4" />
        <field access="rw" desc="Maximum delay in 100MHz clocks from a Saturation Detect to an AGC Detect or Burst Detect. If this delay is exceeded a Saturation Timeout is declared." name="SatDetectTimeoutPeriod" offset="16" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxTdIqBalComp" offset="0x24">
        <field access="rw" desc="Q part of compensation coefficients, format s&lt;11,-2&gt;." name="Qcoef" offset="0" reset="x" width="11" />
        <field access="ru" name="RESERVED" offset="11" reset="x" width="6" />
        <field access="rw" desc="I part of compensation coefficients, format s&lt;11, -2&gt;." name="Icoef" offset="17" reset="x" width="11" />
        <field access="rw" desc="0: IQ imbalance comp disabled ... 1: IQ imbalance comp enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="rw" desc="when 0 - disable spectral inversion, when 1   spectral inversion is done." name="SpecInv" offset="29" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxNotchFilters" offset="0x28">
        <field access="rw" desc="Phase increment for Notch1 rotator. S&lt;12,1&gt; format." name="Notch1Freq" offset="0" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="12" reset="x" width="4" />
        <field access="rw" desc="Phase increment for Notch2 rotator. S&lt;12,1&gt; format." name="Notch2Freq" offset="16" reset="x" width="12" />
        <field access="rw" desc="0: notch filter 1 bypassed 1: notch filter 1 enabled." name="Notch1Enable" offset="28" reset="x" width="1" />
        <field access="rw" desc="0: notch filter 2 bypassed 1: notch filter 2 enabled." name="Notch2Enable" offset="29" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxBurstAcq_0" offset="0x2c">
        <field access="rw" desc="the alpha coeficient of the IIR filter  U&lt;11,1&gt; format." name="EnergyEstSmoothFactor" offset="0" reset="x" width="6" />
        <field access="ru" name="RESERVED" offset="6" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="18" reset="x" width="2" />
        <field access="rw" desc="0: 1 ... 1: 2 ... 2: 4 ... 3: 8 ... Number of symbols in LongSeq1 correlation." name="CorrLongSeq1NumSyms" offset="20" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="2" />
        <field access="rw" desc="1 means that an extra sequence should follow the long sequences." name="CorrLongSeq2Enable" offset="24" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="25" reset="x" width="3" />
        <field access="rw" desc="0: MoCA 1.x Ln ... 1: RxLongRefSeln ... Specifies the set of sequences LongSeq1RefSel and LongSeq2RefSel select from. When '0' the set of hardwired MoCA 1.x reference sequences are used and when '1' the set of programmed sequences for c.LINK+ are used." name="CorrRefSetSel" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxBurstAcq_1" offset="0x30">
        <field access="rw" desc="the offset base value (shifted here up by 0..7)." name="InitialEnergyOffset" offset="0" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="9" />
        <field access="rw" desc="for checking of no update to &quot;max_cpower&quot; within this window." name="CorrPeakSearchWindowLen" offset="16" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RxBurstAcq_2" offset="0x34">
        <field access="rw" desc="the offset shift for extra sequence detection." name="LongSeq2EnergyOffset" offset="0" reset="x" width="3" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="5" />
        <field access="rw" desc="the scale  for  extra sequence detection." name="LongSeq2EnergyScale" offset="8" reset="x" width="7" />
        <field access="rw" desc="the number of samples from the last long peak to the extra peak." name="IdealLongSeq2PeakTime" offset="15" reset="x" width="9" />
        <field access="ru" name="RESERVED" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RxBurstAcq_3" offset="0x38">
        <field access="rw" desc="the delay before before allowing &quot;lseq_peak_detect&quot;. This value would be supplied by system group after further experiments." name="BurstDetectDelay" offset="0" reset="x" width="11" />
        <field access="ru" name="RESERVED" offset="11" reset="x" width="5" />
        <field access="rw" desc="minimum correlaion value which will be part of packet mean time calculation." name="PeakThresholdForMeanTimeCalc" offset="16" reset="x" width="5" />
        <field access="ru" name="RESERVED" offset="21" reset="x" width="5" />
        <field access="rw" desc="0: normal burst detect 1: forced burst detect." name="ForceBurstDetect" offset="26" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="5" />
      </reg>
      <reg name="RxBurstAcq_4" offset="0x3c">
        <field access="rw" desc="the scale  for first  long  sequence detection." name="LseqCorrThdFirstScale" offset="0" reset="x" width="7" />
        <field access="rw" desc="the scale  for second long  sequence detection." name="LseqCorrThdSecondScale" offset="7" reset="x" width="7" />
        <field access="rw" desc="the offset shift for long  sequence detection." name="LseqCorrThdMainOffset" offset="14" reset="x" width="3" />
        <field access="rw" desc="1 - need peak detect confirmation." name="LseqPeakConfirmEnable" offset="17" reset="x" width="1" />
        <field access="rw" desc="(Spar) some options for peak detect confirmation." name="LseqPeakConfirmCya" offset="18" reset="x" width="3" />
        <field access="ru" name="RESERVED" offset="21" reset="x" width="1" />
        <field access="rw" desc="select 1 out of 4 options for the long  sequence (moca1X or moca2X)." name="LongSeqSel" offset="22" reset="x" width="2" />
        <field access="rw" desc="select 1 out of 4 options for the extra sequence (moca1X or moca2X)." name="ExtraSeqSel" offset="24" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="6" />
      </reg>
      <reg name="RxBurstAcq_6" offset="0x44">
        <field access="rw" desc="the ctc time to stop the receive gate ( in terms of 50Mhz clock )." name="RxCntlStopTime" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxOfdmSymFramer_0" offset="0x48">
        <field access="rw" desc="Includes all fixed and profile adjustments to burst detect time to the first FFT input sample. This and the start time (difference between detected peak and calculated mean) are added to the burst detect time to get the time of the first FFT input sample." name="FftFirstSampleAdj" offset="0" reset="x" width="11" />
        <field access="rw" desc="0: no window ... 1: window length 2 ... 2: window length 3 ... 3: window length 4 ... 4: window length 6 ... 5: window length 8 ... 6: window length 12 ... 7: window length 16 ... 8: window length 24 ... 9: window length 48 ... Value greater than 9 is not valid. Selects windown length." name="RxTimeWindowDataLenSel" offset="11" reset="x" width="4" />
        <field access="rw" desc="4 bits which select the CE   window length (including 0)." name="RxTimeWindowCeLenSel" offset="15" reset="x" width="4" />
        <field access="rw" desc="bits which specify the correlation window length" name="RxFramingCorrWindowLen" offset="19" reset="x" width="8"></field>
        <field access="rw" desc="1 : invert the CE-CP accumulated correlation teta" name="RxFramingCorrPol" offset="27" reset="x" width="1"></field>
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxOfdmSymFramer_1" offset="0x4c">
        <field access="rw" desc="Number of data symbols in the received packet. This includes the last data symbol whether or not it is sent to the FFT (see DiscardLastDataSym). Must be greater than 0." name="NumDataSyms" offset="0" reset="x" width="8" />
        <field access="rw" desc="1 : indicate the packet is a hardware EPP packet." name="RxHwEppPkt" offset="8" reset="x" width="1" />
        <field access="rw" desc="1 : software EPP packet mode." name="RxSwEppPkt" offset="9" reset="x" width="1" />
        <field access="rw" desc="1 : don't use &quot;lseq_peak_to_mean&quot; (assume it's 0)." name="IgnorePeakToMeanCya" offset="10" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="11" reset="x" width="5" />
        <field access="rw" desc="Length of the cyclic prefix for data symbols in 100MHz samples. A value of 255 indicates a cplength of 512." name="DataCpLength" offset="16" reset="x" width="8" />
        <field access="rw" desc="Number of channel estimation symbols. Must be 0, 1 or 2." name="NumChanEstSyms" offset="24" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="6" />
      </reg>
      <reg name="RxFft_0" offset="0x50">
        <field access="ru" name="RESERVED" offset="0" reset="x" width="18" />
        <field access="rw" desc="Number of Channel Estimation symbols. Must be 0, 1 or 2." name="NumChanEstSyms" offset="18" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="20" reset="x" width="8" />
        <field access="rw" desc="0: no EPP IFFT following last FFT ... 1: EPP IFFT following last FFT ... When '1' the EPP processor (in the FD section) will send IFFT input data to be processed after the last data symbol input. Note the last data symbol input to the FFT is the penultimate data symbol in the packet when the OFDM framer is so configured." name="EppIfftEnable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxFft_1" offset="0x54">
        <field access="rw" desc="Gain applied to each data symbols' FFT output. This gain is also applied to the EPP IFFT output when present. U&lt;12,1&gt; format?." name="DataGain" offset="0" reset="x" width="12" />
        <field access="rw" desc="1 indicates sw epp data on din_i and din_q and delayed bypass of FFT module." name="SwEppPkt" offset="12" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="13" reset="x" width="3" />
        <field access="rw" desc="Gain applied to channel estimation symbols' FFT output. U&lt;12,1&gt; format?." name="ChanEstGain" offset="16" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxFreqOffsetEst_0" offset="0x58">
        <field access="rw" desc="specifies the initial frequency offset." name="InitialPhase" offset="0" reset="x" width="17" />
        <field access="rw" desc="1 : it's not known if the second long sequences are inverted." name="RxFreqLongInvUnknown" offset="17" reset="x" width="1" />
        <field access="rw" desc="0 : low precision (x2) 1 : high precision (x4)." name="RxFreqFineX4Mode" offset="18" reset="x" width="1" />
        <field access="rw" desc="1 : use just &quot;rx_freq_offset_init&quot; (ignore the correlation)." name="RxFreqOffsetInitOnly" offset="19" reset="x" width="1" />
        <field access="rw" desc="0: second half not inverted 1: second half inverted Specifies whether second half of long sequence is inverted." name="RxFreqLongInvSecond" offset="20" reset="x" width="1" />
        <field access="rw" desc="1 : clear &quot;rx_time_offset&quot; on iq calibration mode." name="RxTimeOffsetIqMode" offset="21" reset="x" width="1" />
        <field access="rw" desc="select moca1x or moca2x conversion factor from freq offset to time offset." name="RxFreqMoca2xMode" offset="22" reset="x" width="1" />
        <field access="rw" desc="the number of samples inside real data fifo at the end of packet (up to 64)" name="RxFreqOffsetMode" offset="23" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RxFreqOffsetEst_1" offset="0x5c">
        <field access="rw" desc="testing I/Q imbalance freq offset." name="RxFreqOffsetIq" offset="0" reset="x" width="22" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="10" />
      </reg>
      <reg name="RxFreqOffsetRotator" offset="0x60">
        <field access="rw" desc="The frequency of notch rotation, format is s&lt;12, 1&gt;." name="NotchFreq" offset="0" reset="x" width="12" />
        <field access="rw" desc="the rotator output phase can be inverted." name="RxRotatorPhaseSign" offset="12" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="13" reset="x" width="14" />
        <field access="rw" desc="0: Acts normally for the whole packet. ... 1: The block goes into bypass mode after receiving pktStart, but acts normally until that point." name="IqCalEn" offset="27" reset="x" width="1" />
        <field access="rw" desc="Set 1 to enable the moca1x rotator." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxCeAnalog" offset="0x064">
        <field access="rw" desc="the amount of 100 samples to wait before starting analog energy accumulation." name="EnergyDelay" offset="0" reset="x" width="13" />
        <field access="rw" desc="0 : count from &quot;rx_detect_start &quot; 1 : count from &quot;lseq_final_detect&quot;." name="EnergyMode" offset="13" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="14" reset="x" width="18" />
      </reg>
      <reg name="RxEventLog" offset="0x068">
        <field access="rw" desc="4 bits packet ID." name="RxCtrlPktId" offset="0" reset="x" width="4" />
        <field access="rw" desc="enable events for the current packet." name="RxEventEnable" offset="4" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="5" reset="x" width="27" />
      </reg>
    </regfile>
  </block>
  <block name="PhyFd" offset="0xcc154000">
    <regfile desc="PhyFd Rx Csbuff (dynamic control register)" name="RxCsbCtl" offset="0x1000" absolute_addr="0xcc155000">
      <mult name="0" num="4" offset="0x100" />
      <reg name="RxFdEntryControl" offset="0x00">
        <field access="rw" desc="Writing a '0' transfers this entry to hardware for processing. Writing a '1' transfers this entry to software for reuse." name="Empty" offset="0" reset="1" width="1" />
        <field access="ru" desc="State of corresponding status entry - see TxEntryStatus register description." name="StatusEmpty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Indicates this entry has been processed (but status not necessarily available). 0: not processed 1: processed." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="29" />
      </reg>
      <reg name="RxCeRot" offset="0x04">
        <field access="rw" desc="0: disable CE rotator ... 1: Use 1/4 mode ... 3: Use 1/8 low delay mode." name="SmoothMode" offset="0" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="2" reset="x" width="6" />
        <field access="rw" desc="This field igored if InputFormatterEmptySymbEnable set to 0. This indicates number of empty symbols to be padded. The number of samples per symbol output at the end of RX FD pipeline is controlled by the bitloading table for IQ probes and SW EPP probes.  It is always 512 samples per symbol for HW EPP probes." name="InputFormatterEmptySymbCount" offset="8" reset="x" width="8" />
        <field access="rw" desc="Setting this field to 1 to enable mantissa exponent conversion. Setting this field to 0 for saturation. This field should be set to 1 for IQ probes." name="InputFormatterMntExpEnable" offset="16" reset="x" width="1" />
        <field access="rw" desc="Setting to 1 to enable empty symbols padding when empty packet detected. This field should be set to 1 for IQ probes, SW EPP probes and HW EPP probes." name="InputFormatterEmptySymbEnable" offset="17" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="18" reset="x" width="14" />
      </reg>
      <reg name="RxFdIqBalComp_0" offset="0x08">
        <field access="rw" desc="First Bin to be compensated. (&gt;= 6 and &lt;= LastBin)." name="FirstBin" offset="0" reset="x" width="8" />
        <field access="rw" desc="Last Bin to be compensated. (&lt;= 250, and &lt;= LastUsedBin)." name="LastBin" offset="8" reset="x" width="8" />
        <field access="rw" desc="Last Bin that is used to send data; (&lt;=255)." name="LastUsedBin" offset="16" reset="x" width="8" />
        <field access="rw" desc="Number of piecewise linear elements minus 1; 0 implies 1 point, 3 implies 4 points." name="Npnts" offset="24" reset="x" width="2" />
        <field access="rw" desc="0: RxBitLoadTable0 ... 1: RxBitLoadTable1 ... 2: RxBitLoadTable2 ... 3: RxBitLoadTable3." name="BitLoadTableSel" offset="26" reset="x" width="2" />
        <field access="rw" desc="0: FD IQ compensation disabled 1: FD IQ compensation enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxFdIqBalComp_1" offset="0x0c">
        <field access="rw" desc="(&gt;6 for correct hw slope initialization)." name="Dbins_0" offset="0" reset="x" width="8" />
        <field access="rw" desc="(&gt;Dbins_0)." name="Dbins_1" offset="8" reset="x" width="8" />
        <field access="rw" desc="(&gt;Dbins_1)." name="Dbins_2" offset="16" reset="x" width="8" />
        <field access="rw" desc="Bin index for each entry in the vector Dslope. (&gt;Dbins_2)." name="Dbins_3" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RxFdIqBalComp_2" offset="0x10">
        <field access="rw" name="Dslope_2" offset="0" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="10" reset="x" width="6" />
        <field access="rw" desc="y-coordinate of breakpoints of piecewise linear curve, S&lt;10,-8&gt;." name="Dslope_3" offset="16" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="6" />
      </reg>
      <reg name="RxFdIqBalComp_3" offset="0x14">
        <field access="rw" name="Dslope_0" offset="0" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="10" reset="x" width="6" />
        <field access="rw" name="Dslope_1" offset="16" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="6" />
      </reg>
      <reg name="RxBinDescrambler" offset="0x18">
        <field access="rw" desc="The initial value of the PN-15 LFSR." name="Seed" offset="0" reset="x" width="15" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="9" />
        <field access="rw" desc="Number of channel estimation symbols. Must be 0, 1 or 2. This field is used to control the entire Rx data path, not just this module." name="NumChanEstSyms" offset="24" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="2" />
        <field access="rw" desc="0: Bin descrambler bypassed ... 1: Bin descrambler enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxChanComp_0" offset="0x1c">
        <field access="rw" desc="0: Cross-bin smoothing disabled ... 1: Cross-bin smoothing 1/4 CP filters ... 3: Cross-bin smoothing 1/8 CP filters ... Controls cross-bin smoothing of the channel estimate." name="ChanEstSmoothMode" offset="0" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="2" reset="x" width="18" />
        <field access="rw" desc="0: TxRxChanEstRef0 ... 1: TxRxChanEstRef1 ... 2: TxRxChanEstRef2." name="ChanEstRefSel" offset="20" reset="x" width="2" />
        <field access="rw" desc="Select one of the 4 EVM data table; Same EVM table would be used by NVE module for current packet." name="EvmTableSel" offset="22" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="24" reset="x" width="3" />
        <field access="rw" desc="0: ID 14 used ... 1: ID 14 treated as ID 0." name="ChanEstSmoothIgnore14" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: Channel compensation bypassed 1: Channel compensation enabled Note that channel estimation is always performed. This enable controls whether channel compensation is performed." name="CompEnable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxChanComp_1" offset="0x20">
        <field access="ru" name="RESERVED" offset="0" reset="x" width="4" />
        <field access="rw" desc="Interference detection threshold level 1, based upon CeMagnSq for setting interference flag = 1." name="InterfDetTheshLvl1" offset="4" reset="x" width="3" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="1" />
        <field access="rw" desc="Interference detection threshold level 1, based upon CeMagnSq for setting interference flag = 2." name="InterfDetTheshLvl2" offset="8" reset="x" width="3" />
        <field access="ru" name="RESERVED" offset="11" reset="x" width="1" />
        <field access="rw" desc="Interference detection threshold level 1, based upon CeMagnSq for setting interference flag = 3." name="InterfDetTheshLvl3" offset="12" reset="x" width="3" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="13" />
        <field access="rw" name="InterfDetEnable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxFreqTimeTrack" offset="0x24">
        <field access="rw" desc="0: RxBinDeintTable0 ... 1: RxBinDeintTable1 ... 2: RxBinDeintTable2 ... 3: RxBinDeintTable3." name="BinDeintTableSel" offset="0" reset="x" width="2" />
        <field access="rw" desc="0: fixed contextID = 0 ... 1: contextID from selected table ... When '1' contextIDs are read from the table selected by BinDeintTableSel. When '0' a fixed contextID of 0 is applied to each subcarrier. This bit controls contextID generation independent of whether the rotator is enabled or not." name="BinDeintEnable" offset="2" reset="x" width="1" />
        <field access="rw" desc="This controls the Phase Detector." name="LockedClocks" offset="3" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="4" reset="x" width="5" />
        <field access="rw" desc="Timing Loop Bandwidth Reduction, the actual reduction is (2**timeBwReduce)." name="timeBwReduce" offset="9" reset="x" width="2" />
        <field access="rw" desc="Freq Loop Bandwidth Reduction, the actual reduction is (2**freqBwReduce)." name="freqBwReduce" offset="11" reset="x" width="2" />
        <field access="rw" desc="0: bypassed 1: enabled." name="EPPRotatorEnable" offset="13" reset="x" width="1" />
        <field access="rw" desc="0: LT rotator bypassed ... 1: LT rotator enabled ... Note the rotator must be bypassed when not used (e.g. differential constellations) since it cannot rotate by an angle of 0." name="LTRotatorEnable" offset="14" reset="x" width="1" />
        <field access="rw" desc="0: CPE rotator bypassed ... 1: CPE rotator enabled ... Note the rotator must be bypassed when not used (e.g. in OFDMA mode) since it cannot rotate by an angle of 0." name="CPERotatorEnable" offset="15" reset="x" width="1" />
        <field access="ru" desc="0: CP Phase Offset from RxTD is not used by LT rotator ... 1: CP Phase Offset is used by LT rotator" name="CpPhaseOffsetEnable" offset="16" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="17" reset="x" width="10" />
        <field access="rw" desc="0: Disable time tracking loop. ... 1: Enable Time tracking loop." name="TimeTrackEnable" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: Disable freq tracking loop. ... 1: Enable freq tracking loop." name="FreqTrackEnable" offset="28" reset="x" width="1" />
        <field access="rw" desc="Use the CE symbols for a head start on the tracking loops." name="enableCEStart" offset="29" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxFreqTimeTrack_1" offset="0x28">
        <field access="rw" desc="Initial Gain for the integral part of the loop. The actual gain is 2 to the power of this field divided by 8." name="TimeStartIntegralGain" offset="0" reset="x" width="3" />
        <field access="rw" desc="Final Gain for the integral part of the loop. The actual gain is 2 to the power of this field divided by 8." name="TimeEndIntegralGain" offset="3" reset="x" width="3" />
        <field access="rw" desc="Number of symbols until jumping from start gains to end gains." name="TimeGearShiftTime" offset="6" reset="x" width="4" />
        <field access="rw" desc="Initial gain for the proportional part of the loop. The actual gain is 2 to the power of this field divided by 4." name="TimeStartGain" offset="10" reset="x" width="2" />
        <field access="rw" desc="Final gain for the proportional part of the loop. The actual gain is 2 to the power of this field divided by 4." name="TimeEndGain" offset="12" reset="x" width="2" />
        <field access="rw" desc="Setting to 1 would invert the input spectrum before sending to phase comparator." name="SpectrumInvert" offset="14" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="1" />
        <field access="rw" desc="See TimeStartIntegralGain." name="FreqStartIntegralGain" offset="16" reset="x" width="3" />
        <field access="rw" desc="See TimeEndIntegralGain." name="FreqEndIntegralGain" offset="19" reset="x" width="3" />
        <field access="rw" desc="See TimeGearShiftTime." name="FreqGearShiftTime" offset="22" reset="x" width="4" />
        <field access="rw" desc="See TimeStartGain." name="FreqStartGain" offset="26" reset="x" width="2" />
        <field access="rw" desc="See TimeEndGain." name="FreqEndGain" offset="28" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxSlicer" offset="0x2C">
        <field access="rw" desc="1: use Zip2 scalers. ... 0: don't use Zip2 scalers. ... This selects the offset used in Zip2 Detector scaler. See Phy Functional Spec for explanation." name="useZipScalers" offset="0" reset="x" width="1" />
        <field access="rw" desc="Slicer AGC gain value, legal value is 0 to 14." name="slicerAgcGain" offset="1" reset="x" width="5" />
        <field access="rw" desc="1: Slicer AGC enable. 0: disabled." name="enableSlicerAGC" offset="6" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="7" />
        <field access="rw" desc="0: Normal (1/Kmod) scaling ... 1: Zip2 (1/Kmod) scaling ... others: reserved." name="ConstDenormUseZip2Scalers" offset="14" reset="x" width="1" />
        <field access="rw" desc="0: Constellation denorm bypassed. ... 1: Constellation denorm enabled ... Note bypass is functionally &quot;High Precision Pass Through&quot; in the Systems PHY spec." name="ConstDenormEnable" offset="15" reset="x" width="1" />
        <field access="rw" desc="For future expansion." name="NveFunction" offset="16" reset="x" width="2" />
        <field access="rw" desc="0: Nve not enabled, all other NVE control registers are ignored. NVE status is invalid and forced to 0. NVE events are NOT generated. NVE accumulator/memory is disabled and not written. NVE InvVarEst output is forced to 0. ... 1: Nve enabled. All other NVE control registers are used. NVE status is valid at the end of packet. NVE events can be generated. NVE accumulator/ memory is updated. NVE InvVarEst output is computed per other control params." name="NveEnbl" offset="18" reset="x" width="1" />
        <field access="rw" desc="0: Don't reset NVE accumulator on packet start 1: reset NVE accumulator on packet start." name="NveResetPacketStart" offset="19" reset="x" width="1" />
        <field access="rw" desc="NVE enable interference estimation." name="NveIntfEstEnbl" offset="20" reset="x" width="1" />
        <field access="rw" desc="NVE diversity mode right shift amount." name="NveDivShift" offset="21" reset="x" width="2" />
        <field access="rw" desc="0: select evm-based noise variance 1: select channel estimate based noise variance." name="NveSelStatic" offset="23" reset="x" width="1" />
        <field access="rw" desc="U3 format." name="SquelchMode" offset="24" reset="x" width="3" />
        <field access="rw" desc="Set to 1 to enable sign extension of bypass data when in received point bypass mode to sign extend 13 bit I/Q values to 16 bit outputs. ... Set to 1 for SW EPP probes, and ADC data samples. Otherwise set to 0." name="BypassSignExtEnbl" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: Normal data ... 1: Diversity 2 bytes ... 2: Diversity 4 bytes ... 3: Diversity 8 bytes ... 4: Received point bypass ... Note the receiver supports at most sixteen data repetitions in diversity mode - the number of input bytes per symbol must be at least one-sixteenth the number of active subcarriers. In &quot;received point bypass&quot; mode the slicer outputs the received data point for each non-NULL subcarrier. The DLL must use 32-bit bypass mode to transfer these to the DMA. See Rx Probe Processing for details." name="Mode" offset="28" reset="x" width="3" />
        <field access="ru" desc="0: TxRxDiversityOffset0 1: TxRxDiversityOffset1." name="DiversityOffsetSel" offset="31" reset="x" width="1" />
      </reg>
      <reg name="RxEvmSaProc" offset="0x30">
        <field access="rw" desc="Number of first symbol to process. Data symbols are numbered starting from 0 for the first data symbol in the packet. The packet must contain at least the number of data symbols indicated by StartSym+NumSyms or the results are undefined." name="StartSym" offset="0" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="1" />
        <field access="rw" desc="Number of data symbols to process. The packet must contain at least the number of data symbols indicated by StartSym+NumSyms or the results are undefined. Must be greater than 0." name="NumSyms" offset="8" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="1" />
        <field access="rw" desc="Carrier with 2**Threshold times greather than mean power should be counted." name="Threshold1" offset="16" reset="x" width="3" />
        <field access="rw" desc="This field represents (N/(N-1))-1. This is used to compensate threshold for only computing mean over N-1 symbols." name="Threshold2" offset="19" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="3" />
        <field access="rw" desc="0: accumulate from current values ... 1: set accumulators to 0 before processing if pauseEVM is set, reset is prevented." name="StatResetPacketStart" offset="26" reset="x" width="1" />
        <field access="rw" desc="Set to 1 to pause the EVM accumulation for the current packet. When set, only the EVM/SA status outputs MeanMantissa and MeanExponent status outputs ofare valid EVM/SA are invalid." name="pauseEVM" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: EVM/SA processor disabled ... 1: EVM/SA processor enabled ... When enabled the EVM/SA processor results are computed and output to the DLL. EPP processor must be disabled when enabling EVM/SA. The DLL must use 32-bit bypass mode to transfer these results to the DMA. If the packet is not received (burst detect failure, etc.) the accumulators are not modified and the current accumulator contents are returned as the results. When disabled the accumulated results from prior processing are held." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxEppProc" offset="0x34">
        <field access="rw" desc="Number of first symbol to process. Data symbols are numbered starting from 0 for the first data symbol in the packet. Note! if programmed incorrectly can hang the processing path.  See formula in NumSyms." name="StartSym" offset="0" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="1" />
        <field access="rw" desc="Number of data symbols to process. Must be greater than 0. Note! if programmed incorrectly, this can hang the processing path.  Formula: StartSym + NumSyms &lt;= NumSymsIntoFdRx - NumCeSyms - 1 whenever EppProc is Enabled." name="NumSyms" offset="8" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="13" />
        <field access="rw" desc="0: EPP processor disabled ... 1: EPP processor enabled ... When enabled EPP processor results are computed and output to the DLL. EVM/SA processor must be disabled when EPP processor is enabled. The DLL must use 32-bit bypass mode to transfer these results to the DMA." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxFdBerTest" offset="0x38">
        <field access="rw" desc="Setting this field to 1 enable FD Rx events logging." name="EventEnable" offset="0" reset="x" width="1" />
        <field access="rw" desc="This field is sent along with events to the logger. Software use this tag to line up PHY events and DMA engine events." name="EventPktID" offset="1" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="5" reset="x" width="15" />
        <field access="rw" desc="OFDMA context to check and update the cumulative statistics with. Bit 0 enable context 0 and bit 1 enable context 1 and so on. For non OFDMA, only bit 0 should be set to 1." name="ContextIDMask" offset="16" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="24" reset="x" width="1" />
        <field access="rw" desc="0: LFSR continues at symbol start ... 1: LFSR set to seed at symbol start." name="PnResetSymStart" offset="25" reset="x" width="1" />
        <field access="rw" desc="0: LFSR continues at packet start ... 1: LFSR set to seed at packet start." name="PnResetPacketStart" offset="26" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: FD BERT checker disabled 1: FD BERT checker enabled When enabled the received packet is checked as specified by Mode and the cumulative statistics updated as appropriate. When disabled no checking is performed and the cumulative statistics are unchanged." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
    </regfile>
  </block>
  <block name="PhyDl" offset="0xcc150000">
    <regfile desc="PhyDl Rx Csbuff (dynamic control register)" name="RxCsbCtl" offset="0x1000" absolute_addr="0xcc151000">
      <mult name="0" num="4" offset="0x100" />
      <reg name="RxDllEntryControl" offset="0x00">
        <field access="rw" desc="Writing a '0' transfers this entry to hardware for processing. Writing a '1' transfers this entry to software for reuse." name="Empty" offset="0" reset="1" width="1" />
        <field access="ru" desc="State of corresponding status entry - see TxEntryNStatus register description." name="StatusEmpty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Indicates this entry has been processed (but status not necessarily available). 0: not processed 1: processed." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="29" />
      </reg>
      <reg name="RxDllInputControl" offset="0x04">
        <field access="rw" desc="Setting this field to 1 enable DLL Rx events logging." name="EventEnable" offset="0" reset="x" width="1" />
        <field access="rw" desc="This field is sent along with events to the logger. Software use this tag to line up PHY events and DMA engine events." name="EventPktID" offset="1" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="5" reset="x" width="23" />
        <field access="rw" desc="0: 10 LLR (Normal) ... 1: 32-bit bypass." name="InputFormat" offset="28" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxByteUnscrambler_0" offset="0x08">
        <field access="rw" desc="The base initial value of the PN-23 LFSRs. The initial value of each context's LFSR is the bitwise XOR of this value and the value in the SeedMod array selected by the context ID repeated 5 3/4 times." name="Seed" offset="0" reset="x" width="23" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="5" />
        <field access="rw" desc="0: Byte unscrambler bypassed ... 1: Byte unscrambler enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxByteUnscrambler_1" offset="0x0c">
        <field access="rw" desc="Value is repeated 5 3/4 times to yield a 23-bit value that is bitwise XORed with Seed. The result is the associated context's initial LFSR seed." name="SeedMod_0" offset="0" reset="x" width="4" />
        <field access="rw" name="SeedMod_1" offset="4" reset="x" width="4" />
        <field access="rw" name="SeedMod_2" offset="8" reset="x" width="4" />
        <field access="rw" name="SeedMod_3" offset="12" reset="x" width="4" />
        <field access="rw" name="SeedMod_4" offset="16" reset="x" width="4" />
        <field access="rw" name="SeedMod_5" offset="20" reset="x" width="4" />
        <field access="rw" name="SeedMod_6" offset="24" reset="x" width="4" />
        <field access="rw" name="SeedMod_7" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxByteUnscrambler_2" offset="0x10">
        <field access="rw" name="SeedMod_8" offset="0" reset="x" width="4" />
        <field access="rw" name="SeedMod_9" offset="4" reset="x" width="4" />
        <field access="rw" name="SeedMod_10" offset="8" reset="x" width="4" />
        <field access="rw" name="SeedMod_11" offset="12" reset="x" width="4" />
        <field access="rw" name="SeedMod_12" offset="16" reset="x" width="4" />
        <field access="rw" name="SeedMod_13" offset="20" reset="x" width="4" />
        <field access="rw" name="SeedMod_14" offset="24" reset="x" width="4" />
        <field access="rw" name="SeedMod_15" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxLdpcDec_0" offset="0x14">
        <field access="rw" desc="The number of LDPC block sets plus one to decode using the InitialK and InitialCodeSel parameters. One final block set is decoded using the FinalK and FinalCodeSel parameters. Must be greater than 0." name="NumSets" offset="0" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="10" reset="x" width="6" />
        <field access="rw" desc="0: 4608 rate 19/24 ... 1: 576 rate 3/4 (OFDMA) ... 15: NULL rate 1/1 ... Code for the last block set." name="FinalCodeSel" offset="16" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="20" reset="x" width="2" />
        <field access="rw" desc="0: 4608 rate 19/24 ... 1: 576 rate 3/4 ... 15: NULL rate 1/1 ... Code for the first NumSets-1 block sets." name="InitialCodeSel" offset="22" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="2" />
        <field access="rw" desc="0: LDPC decoder 32-bit bypass ... 1: LDPC decoder enabled ... 2: LDPC decoder LLR bypass ... The decoder drains before bypassing either input LLRs or input 32-bit data; sufficient delay at the receiver input is required to ensure bypass data is not lost." name="Enable" offset="28" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
      <reg name="RxLdpcDec_1" offset="0x18">
        <field access="rw" desc="Number of data bits per LDPC codeword for the last set. The selected LDPC code is shortened as required to this data length. Must be greater than 0 and less than or equal to the native K of the selected code (or 4608 for the NULL code). Restricted to multiple of 8 for OFDMA." name="FinalK" offset="0" reset="x" width="13" />
        <field access="ru" name="RESERVED" offset="13" reset="x" width="3" />
        <field access="rw" desc="Number of data bits per LDPC codeword for the first NumSets-1 sets. The selected LDPC code is shortened as required to this data length. Must be greater than 0 and less than or equal to the native K of the selected code (or 4608 for the NULL code). Restricted to multiple of 8 for OFDMA." name="InitialK" offset="16" reset="x" width="13" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxLdpcDec_2" offset="0x1c">
        <field access="rw" desc="Maximum number of iterations allowed to decode a block set. After reaching this limit the decoder stops and outputs the current result whether it successfully decoded or not. Applies to block sets decoded after end-of-packet is received." name="MaxItersPktEnd" offset="0" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="4" reset="x" width="4" />
        <field access="rw" desc="Maximum number of iterations allowed to decode a block set. After reaching this limit the decoder stops and outputs the current result whether it successfully decoded or not. Applies to block sets decoded before end-of-packet is received." name="MaxIters" offset="8" reset="x" width="4" />
        <field access="ru" name="RESERVED" offset="12" reset="x" width="16" />
        <field access="rw" desc="0: disable early stop condition ... 1: enable early stop condition ... When enabled the decoder will stop iterating when all codewords in the block set have met the early stop condition. When disabled the decoder will iterate until reaching the MaxIters/MaxItersPktEnd limit or the input buffer space is exhausted, whichever occurs first." name="EarlyStopEnable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxLdpcDec_3" offset="0x20">
        <field access="rw" desc="Number of blocks (codewords) per set for the associated context. Must be in the range 0..15. When the 4608 (non-OFDMA) code is selected there must be 1 block for context 0 and 0 blocks for the remaining contexts. When the 576 (OFDMA) code is selected the sum of all entries (the number of blocks per set) must be 8 or less. When the NULL code is selected the sum of all entries (the number of blocks per set) must be 16 or less, and the total number of bytes in the set less than 4608." name="ContextNumBlks_0" offset="0" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_1" offset="4" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_2" offset="8" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_3" offset="12" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_4" offset="16" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_5" offset="20" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_6" offset="24" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_7" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxLdpcDec_4" offset="0x24">
        <field access="rw" name="ContextNumBlks_8" offset="0" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_9" offset="4" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_10" offset="8" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_11" offset="12" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_12" offset="16" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_13" offset="20" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_14" offset="24" reset="x" width="4" />
        <field access="rw" name="ContextNumBlks_15" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxByteDeinterleaver" offset="0x28">
        <field access="rw" desc="The number of rows to deinterleave. Must be greater than 1 (due to implementation limitation). The number of columns times the number of rows must be greater than 6 (due to implementation limitation) and 160 or less." name="NumRows" offset="0" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="1" />
        <field access="rw" desc="The number of columns to deinterleave. Must be greater than 1 (due to implementation limitation). The number of columns times the number of rows must be greater than 6 (due to implementation limitation) and 160 or less." name="NumCols" offset="8" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="13" />
        <field access="rw" desc="0: Deinterleaver bypassed 1: Deinterleaver enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxRsDec_0" offset="0x2c">
        <field access="rw" desc="The total number of Reed-Solomon blocks to decode. The first NumBlks-1 blocks are decoded using the InitialK and InitialT parameters. One last block is decoded using the FinalK and FinalT parameters. Any further input is discarded. Must be greater than 0. When 1 the single block is decoded using the final parameters." name="NumBlks" offset="0" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="8" reset="x" width="8" />
        <field access="rw" desc="Reed-Solomon decoder T parameter for the last block. Supported values are 3,4,5,6,8." name="FinalT" offset="16" reset="x" width="6" />
        <field access="rw" desc="Reed-Solomon decoder T parameter for the first NumBlks-1 blocks. Supported values are 3,4,5,6,8." name="InitialT" offset="22" reset="x" width="6" />
        <field access="rw" desc="0: R-S decoder bypassed 1: R-S decoder enabled." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxRsDec_1" offset="0x30">
        <field access="rw" desc="Reed-Solomon decoder K parameter for the last block. Must be greater than 1 and such that the overall codeword length (N=K+2T) is less than 256." name="FinalK" offset="0" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="8" reset="x" width="8" />
        <field access="rw" desc="Reed-Solomon decoder K parameter for the first NumBlks-1 blocks. Must be greater than 1 and such that the overall codeword length (N=K+2T) is less than 256." name="InitialK" offset="16" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RxDataPattCheck" offset="0x34">
        <field access="ru" name="RESERVED" offset="0" reset="x" width="20" />
        <field access="rw" desc="OFDMA context to check and update the cumulative statistics with. Must be set to 0 for non-OFDMA packets." name="ContextID" offset="20" reset="x" width="4" />
        <field access="rw" desc="0: PN23 ... 1: PN23 Serial ... 2: RAMP ... 3: TWO-BYTE ... See TxPattGen.PattSelect for pattern descriptions." name="PattSelect" offset="24" reset="x" width="2" />
        <field access="rw" desc="0: Pattern state continues at packet start ... 1: Pattern state initialized at packet start Only used when the PN23, PN23 Serial or RAMP patterns are selected. ... When '1' the pattern generator state is initialized at the start of the packet - see InitialPatternState for details. Must be '1' when PattSelect differs from the previous packet (i.e. the pattern is changed) for the state of the pattern generator to be defined. For the PN23 pattern this bit being '1' at the start of a packet also forces the pattern generator to the 'synchronized' state, inhibiting pattern re-synchronization for that packet." name="PattResetPacketStart" offset="26" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="1" />
        <field access="rw" desc="0: Pattern checker disabled ... 1: Pattern checker enabled ... When enabled the received packet is checked and the cumulative statistics updated as appropriate. When disabled no checking is performed and the cumulative statistics are unchanged." name="Enable" offset="28" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="29" reset="x" width="3" />
      </reg>
      <reg name="RxDllOutputControl" offset="0x38">
        <field access="ru" name="RESERVED" offset="0" reset="x" width="28" />
        <field access="rw" desc="0: normal operation ... 1: 32-bit bypass ... 2: discard output data DLL receive section output mode. ... In 'normal' mode 8 bits are output at a time to the DMA; this must be selected when the DLL receive section is processing normal packet data. In '32-bit-bypass' mode 32 bits are output at a time to the DMA; this must be selected when the DLL receive section is bypassing 32-bit probe results or packet data samples. In 'discard-output-data' mode the output data is discarded without passing to the DMA." name="Mode" offset="28" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="30" reset="x" width="2" />
      </reg>
    </regfile>
  </block>
  <block name="PhyTd" offset="0xcc158000">
    <regfile desc="PhyTd Rx Csr Status (static status register)" name="RxCsr" offset="0x0600" absolute_addr="0xcc158600">
      <reg name="RxCtrlStatus_0">
        <field access="ru" desc=" RevB and beyond. For debug only :the status depends on the value of the static parameter &quot;RxCtrlStatusCya&quot;[1:0] ... 0 : ... bit[6:0]   : the control fsm state ... bit[7]     : the packet ID&#xD;&#xA; ... bit[14:8]  : analog gain&#xD;&#xA; ... bit[15]    : repeat is on ... bit[19:16] : &quot;gnt_cnt&quot;&#xD;&#xA; ... bit[23:20] : &quot;req_cnt&quot;&#xD;&#xA; ... bit[25:24] : &quot;pkt_ok_cnt&quot;   ( see above )&#xD;&#xA; ... bit[27:26] : &quot;pkt_bad_cnt&quot;  ( see above )&#xD;&#xA; ... bit[31:28] : &quot;pkt_status&quot;   ( see above )&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; ... 1 : ... bit[6:0]   : the control fsm state&#xD;&#xA; ... bit[7]     : packet error&#xD;&#xA; ... bit[14:8]  : analog_gain&#xD;&#xA; ... bit[15]    : repeat is on&#xD;&#xA; ... bit[23:16] : digital gain&#xD;&#xA; ... bit[25:24] : &quot;pkt_ok_cnt&quot;   ( see above )&#xD;&#xA; ... bit[27:26] : &quot;pkt_bad_cnt&quot;  ( see above )&#xD;&#xA; ... bit[31:28] : &quot;pkt_status&quot;   ( see above )&#xD;&#xA;&#xD;&#xA; ... 2 : ... bit[31:0]  : ctc_timer100[32:1]&#xD;&#xA;&#xD;&#xA; ... 3 : the following status will be latched on the first detected packet error.&#xD;&#xA;                  setting &quot;rx_ctrl_status_cya&quot; to 0 and then 3 again will trigger it again.&#xD;&#xA;&#xD;&#xA; ... bit[0]     : dout   &quot;req&quot; error&#xD;&#xA; ... bit[1]     : status &quot;req&quot; error&#xD;&#xA;     ... bit[3:2]   : &quot;pkt_err_src&quot; ( see above )&#xD;&#xA; ... bit[7:4]   : &quot;pkt_status&quot;  ( see above )&#xD;&#xA; ... bit[9:8]   : &quot;pkt_ok_cnt&quot;  ( see above )&#xD;&#xA; ... bit[11:10] : &quot;pkt_bad_cnt&quot; ( see above )&#xD;&#xA; ... bit[15:12] : &quot;gnt_cnt&quot;&#xD;&#xA; ... bit[19:16] : &quot;req_cnt&quot;&#xD;&#xA;       ... bit[20]    : packet ID&#xD;&#xA; ... bit[28:21] : analog gain&#xD;&#xA;" name="RxCtrlStaticStatus" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxCtrlStatus_1">
        <field access="ru" desc="RevB and beyond. the 16 bits CRC result of the I/Q inputs" name="RxRfIfcCrcResult" offset="0" reset="x" width="16" />
        <field access="ru" desc="RevB and beyond.  1 : indicate that the CRC result is ready" name="RxRfIfcCrcRdy" offset="16" reset="x" width="1" />
        <field access="ru" desc="3 bits which indicate the FIFO lock status" name="RxA2dFifoStatus" offset="17" reset="x" width="2" />
        <field access="ru" desc="if high, FFT state machine schedule is bad and data may be overriden in processing memory. cleared when &quot;rx_fft_status_clr&quot; is high" name="RxFftOvfErr" offset="19" reset="x" width="1" />
        <field access="ru" desc="the number of detections has filled completely its memory ( sticky )" name="RxFreqOffset2DetOvf" offset="20" reset="x" width="1" />
        <field access="ru" desc="number of new algorithm detections in 128*en100" name="RxFreqOffset2DetCnt" offset="21" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
    </regfile>
  </block>
  <block name="PhyFd" offset="0xcc154000">
    <regfile desc="PhyFd Rx Csr Status (static status register)" name="RxCsr" offset="0x0400" absolute_addr="0xcc154400">
      <reg name="RxFdBerTestStatus_0">
        <field access="ru" desc="Cumulative number of symbols checked at the last status refresh. See the Refresh bit description for further details." name="NumSyms" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxFdBerTestStatus_1">
        <field access="ru" desc="Cumulativer number of symbol errors (symbols with at least one bin error) at the last status refresh. See the Refresh bit description for further details." name="NumSymErrs" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxFdBerTestStatus_2">
        <field access="ru" desc="Cumulative number of bins checked at the last status refresh. See the Refresh bit description for further details." name="NumBins" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxFdBerTestStatus_3">
        <field access="ru" desc="Cumulativer number of bin errors (bins with at least one bit error) at the last status refresh. See the Refresh bit description for further details." name="NumBinErrs" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxFdBerTestStatus_4">
        <field access="ru" desc="Cumulative number of bits checked at the last status refresh. See the Refresh bit description for further details." name="NumBits" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxFdBerTestStatus_5">
        <field access="ru" desc="Cumulative number of bit errors at the last status refresh. See the Refresh bit description for further details." name="NumBitErrs" offset="0" reset="x" width="32" />
      </reg>
    </regfile>
  </block>
  <block name="PhyDl" offset="0xcc150000">
    <regfile desc="PhyDl Rx Csr Status (static status register)" name="RxCsr" offset="0x0400" absolute_addr="0xcc150400">
      <reg name="RxPattCheckStatus_0" offset="0x18">
        <field access="ru" desc="Cumulative number of packets checked that were outlier packets at the last status refresh. See the Refresh bit description for further details." name="NumOutlierPackets" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxPattCheckStatus_1" offset="0x1c">
        <field access="ru" desc="Cumulative number of packets checked that were not outlier packets at the last status refresh. See the Refresh bit description for further details." name="NumPackets" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxPattCheckStatus_2" offset="0x20">
        <field access="ru" desc="Cumulative number of packet errors (packets with at least one bit error) at the last status refresh. See the Refresh bit description for further details." name="NumPacketErrs" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxPattCheckStatus_3" offset="0x24">
        <field access="ru" desc="Cumulative number of bytes checked at the last status refresh. See the Refresh bit description for further details." name="NumBytes" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxPattCheckStatus_4" offset="0x28">
        <field access="ru" desc="Cumulative number of byte errors (bytes with at least one bit error) at the last status refresh. See the Refresh bit description for further details." name="NumByteErrs" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxPattCheckStatus_5" offset="0x2c">
        <field access="ru" desc="Cumulative number of bit errors at the last status refresh. See the Refresh bit description for further details." name="NumBitErrs" offset="0" reset="x" width="32" />
      </reg>
    </regfile>
  </block>
  <block name="PhyTd" offset="0xcc158000">
    <regfile desc="PhyTd Rx Csbuff Status (dynamic status register)" name="RxCsbSts" offset="0x1080" absolute_addr="0xcc159080">
      <mult name="0" num="4" offset="0x100" />
      <reg name="RxTdEntryStatus" offset="0x00">
        <field access="rw" desc="Alias - see TxTdEntryControl register description." name="ControlEmpty" offset="0" reset="1" width="1" />
        <field access="rw" desc="Set to '0' by hardware to indicate the entry has valid status. Writing a '1' indicates the entry is transferred to hardware for reuse." name="Empty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Alias - see RxTdEntryControl register description." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="1" />
        <field access="ru" desc="How does this happen?." name="RxTdControlUnderflow" offset="4" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="RxTdStatusLost" offset="5" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="RxTdStatusOverflow" offset="6" reset="0" width="1" />
        <field access="ru" desc="0: Normal mode. ...1: register mode." name="buff_mode" offset="7" reset="0" width="1" />
        <field access="ru" desc="csbuff control read pointer" name="CtrlRdPtr" offset="8" reset="0" width="4" />
        <field access="ru" desc="csbuff status read pointer" name="StatusWrPtr" offset="12" reset="0" width="4" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxRfIfcStatus" offset="0x04">
        <field access="ru" desc="Estimated DC bias in the Q channel. S&lt;8,-2&gt; format." name="EstDcBiasQ" offset="0" reset="x" width="10" />
        <field access="ru" desc="Estimated DC bias in the I channel. S&lt;8,-2&gt; format." name="EstDcBiasI" offset="10" reset="x" width="10" />
        <field access="ru" desc="bit[0]   : &quot;pkt_err_bit&quot;&#xD;&#xA; ... 0 : normal&#xD;&#xA; ... 1 : packet bad ( see &quot;pkt_err_src&quot; )&#xD;&#xA;&#xD;&#xA;  ... bit[1]   : &quot;req_err&quot;&#xD;&#xA;  ... 0 : normal&#xD;&#xA; ... 1 : &quot;dout_req&quot; or &quot;stat_req&quot; error&#xD;&#xA;&#xD;&#xA;  ... bit[3:2] : &quot;pkt_err_src&quot; ( assuming that &quot;pkt_err_bit&quot; is 1 )&#xD;&#xA;  ... 0 : failed to get OFDM after AcqFinished. also end of receive window while still receiving data.&#xD;&#xA; ... 1 : large TTG when getting the packet descriptor&#xD;&#xA; ... 2 : end of the detection gate&#xD;&#xA; ... 3 : no AcqFinished after BurstDetect&#xD;&#xA;&#xD;&#xA;  ... bit[4] : mClear      during the detection gate&#xD;&#xA; ... bit[5] : mReset      during the detection gate&#xD;&#xA; ... bit[6] : PeakDetect  during the detection gate&#xD;&#xA;            ... bit[7] : BurstDetect during the detection gate&#xD;&#xA;" name="PktErr" offset="20" reset="x" width="8" />
        <field access="ru" desc="0:module_saturation ... bit[0] : rf_ifc    saturation&#xD;&#xA; ... bit[1] : resampler saturation&#xD;&#xA; ... bit[2]   : notch     saturation&#xD;&#xA; ... bit[3]   : dig_gain  saturation&#xD;&#xA;&#xD;&#xA;             ... 1 : ... bit[1:0] : pkt_ok_cnt  - a 2 bit counter of good packets ( wraps around from 3 to 0 )&#xD;&#xA;  ... bit[3:2] : pkt_bad_cnt - a 2 bit counter of bad  packets ( wraps around from 3 to 0 )&#xD;&#xA;&#xD;&#xA; ... 2 : ... bit[0]   : extra detection in the first  bin of the extra detection gate&#xD;&#xA; ... bit[1]   : extra detection in the middle bin of the extra detection gate&#xD;&#xA; ... bit[2]   : extra detection in the last   bin of the extra detection gate&#xD;&#xA; ... bit[3]   : no extra detection within the detection window&#xD;&#xA;&#xD;&#xA;" name="PktSat" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxAgcStatus_0" offset="0x08">
        <field access="ru" desc="(before final AGC adjustment.) U&lt;15,8&gt; format?." name="FinalAnalogEnergy" offset="0" reset="x" width="15" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="17" />
      </reg>
      <reg name="RxAgcStatus_1" offset="0x0c">
        <field access="ru" desc="U&lt;15,8&gt; format?." name="FinalDigitalEnergy" offset="0" reset="x" width="15" />
        <field access="ru" name="RESERVED" offset="15" reset="x" width="17" />
      </reg>
      <reg name="RxAgcStatus_2" offset="0x10">
        <field access="ru" desc="Number of Sat2 saturations detected." name="AgcSatDetect4Rd" offset="0" reset="x" width="2" />
        <field access="ru" name="LargeDetectCnt" offset="2" reset="x" width="2" />
        <field access="ru" name="SseqDetectCnt" offset="4" reset="x" width="2" />
        <field access="ru" name="RESERVED" offset="6" reset="x" width="26" />
      </reg>
      <reg name="RxLongTermAgcStatus_0" offset="0x14">
        <field access="ru" desc="Total energy of 1024 200 MHz samples. U&lt;16,8&gt; format." name="AnalogEnergy" offset="0" reset="x" width="16" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxLongTermAgcStatus_1" offset="0x18">
        <field access="ru" desc="Total energy of 512 100 MHz samples. U&lt;16,7&gt; format." name="DigitalEnergy" offset="0" reset="x" width="16" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxBurstAcqStatus_0" offset="0x1c">
        <field access="ru" name="MeanStartTime" offset="0" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="8" reset="x" width="24" />
      </reg>
      <reg name="RxBurstAcqStatus_2" offset="0x20">
        <field access="ru" desc="the status depends on the value of the static parameter &quot;RxCtrlDetectCtcCya&quot;&#xD;&#xA;             0 : the delay from gate start to BurstDetect in units of 50Mhz&#xD;&#xA;             1 : the absolute value of CTC_TIMER at BurstDetect in units of 100Mhz&#xD;&#xA;&#xD;&#xA;" name="RxCtrlBurstDetectCtc4Rd" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RxFreqOffsetEstStatus" offset="0x24">
        <field access="ru" name="FreqOffsetEstimate" offset="0" reset="x" width="17" />
        <field access="ru" name="RESERVED" offset="17" reset="x" width="15" />
      </reg>
      <reg name="RxCtrl" offset="0x28">
        <field access="ru" desc="Estimated frequency offset.               S&lt;17,-5&gt;format." name="DigitalGain4Rd" offset="0" reset="x" width="9" />
        <field access="ru" name="AnalogGain4Rd" offset="9" reset="x" width="7" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxCtrlSynStatus" offset="0x2c">
        <field access="ru" desc="TBD" name="FramingCpFreqOffset_4rd" offset="0" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="12" reset="x" width="20" />
      </reg>
    </regfile>
    <regfile desc="PhyTd Rx Long Sequence Reference Table" name="RxLongSeqRefTbls" offset="0x1800" absolute_addr="0xcc159800">
      <mult name="0" num="4" offset="0x40" />
      <reg name="RxLongSeqRefReg" offset="0x0">
        <field access="rw" desc="This array defines a time-domain sequence to cross correlate with the received c.LINK+ long-sequence symbols. (MoCA 1.x time-domain sequences are hardwired.) Each array element encodes the I and Q components of the sample as follows: Ele[3:2] ... 0: I = 0 ... 1: I = 1 ... 3: I = -1 Ele[1:0] ... 0: Q = 0 ... 1: Q = 1 ... 3: Q = -1" name="RxLongSeqRef_0" offset="0" reset="x" width="4" />
        <field access="rw" name="RxLongSeqRef_1" offset="4" reset="x" width="4" />
        <field access="rw" name="RxLongSeqRef_2" offset="8" reset="x" width="4" />
        <field access="rw" name="RxLongSeqRef_3" offset="12" reset="x" width="4" />
        <field access="rw" name="RxLongSeqRef_4" offset="16" reset="x" width="4" />
        <field access="rw" name="RxLongSeqRef_5" offset="20" reset="x" width="4" />
        <field access="rw" name="RxLongSeqRef_6" offset="24" reset="x" width="4" />
        <field access="rw" name="RxLongSeqRef_7" offset="28" reset="x" width="4" />
        <mult name="0" num="16" offset="0x4" />
      </reg>
    </regfile>
    <regfile desc="PhyTd Rx Allowed Final Gain Adjust Table" name="RxAllowFinalGainAdj" offset="0x1900" absolute_addr="0xcc159900">
      <mult name="0" num="1" offset="0x0" />
      <reg name="RxAllowFinalGainAdj" offset="0x0">
        <field access="rw" desc="This array indicates whether gain changes of +1, +2, -1 and -2 dB are allowed during final gain adjust from the specified(by index) gain level." name="AdiEn_0" offset="0" reset="x" width="4" />
        <field access="rw" name="AdiEn_1" offset="4" reset="x" width="4" />
        <field access="rw" name="AdiEn_2" offset="8" reset="x" width="4" />
        <field access="rw" name="AdiEn_3" offset="12" reset="x" width="4" />
        <field access="rw" name="AdiEn_4" offset="16" reset="x" width="4" />
        <field access="rw" name="AdiEn_5" offset="20" reset="x" width="4" />
        <field access="rw" name="AdiEn_6" offset="24" reset="x" width="4" />
        <field access="rw" name="AdiEn_7" offset="28" reset="x" width="4" />
        <mult name="0" num="12" offset="0x4" />
      </reg>
    </regfile>
  </block>
  <block name="PhyFd" offset="0xcc154000">
    <regfile desc="PhyFd Rx Csbuff Status (dynamic status register)" name="RxCsbSts" offset="0x1080" absolute_addr="0xcc155080">
      <mult name="0" num="4" offset="0x100" />
      <reg name="RxFdEntryStatus" offset="0x00">
        <field access="rw" desc="Alias - see TxFdEntryControl register description." name="ControlEmpty" offset="0" reset="1" width="1" />
        <field access="rw" desc="Set to '0' by hardware to indicate the entry has valid status. Writing a '1' indicates the entry is transferred to hardware for reuse." name="Empty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Alias - see RxFdEntryControl register description." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="1" />
        <field access="ru" desc="How does this happen?." name="RxFdControlUnderflow" offset="4" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="RxFdStatusLost" offset="5" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="RxFdStatusOverflow" offset="6" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="25" />
      </reg>
      <reg name="RxFreqTimeTrackStatus" offset="0x04">
        <field access="ru" desc="The 16 MSB bits of the tracking integral value of the context selected by the IntegralStatusContextID field." name="TimeTrackingIntegral" offset="0" reset="x" width="16" />
        <field access="ru" desc="The 16 MSB bits of the tracking integral value of the context selected by the IntegralStatusContextID field." name="FreqTrackingIntegral" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxEvmSaStatus" offset="0x08">
        <field access="ru" desc="Number of carriers greater than threshold." name="NumCarrierAboveThresh" offset="0" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="8" reset="x" width="5" />
        <field access="ru" desc="Max subtract min, results in 2**MaxVersusMean." name="MaxVersusMean" offset="13" reset="x" width="3" />
        <field access="ru" desc="Bin location of peak." name="LocationOfMax" offset="16" reset="x" width="9" />
        <field access="ru" name="RESERVED" offset="25" reset="x" width="7" />
      </reg>
      <reg name="RxEvmSaSlicerAgcStatus" offset="0x0c">
        <field access="ru" desc="The likelihood of the transmitting packet is having Zip2 scaling problem. Format is s&lt;12,12&gt;." name="Zip2Accum" offset="0" reset="x" width="12" />
        <field access="ru" desc="Mantissa  for mean value. Format is G type U&lt;11,-1&gt;." name="MeanMantissa" offset="12" reset="x" width="11" />
        <field access="ru" desc="Exponent for mean value. Format is U&lt;5,5&gt; positive exponent." name="MeanExponent" offset="23" reset="x" width="5" />
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RxMiscStatus" offset="0x10">
        <field access="ru" desc="Saturation error occurred on HW EPP output interface and indicates the upper 4 bits were not simply redundant sign bits and therefore FFT gain scaling may be too high." name="InputFormatterSatErrHw" offset="0" reset="x" width="1" />
        <field access="ru" desc="Saturation error occurred on normal output interface and indicates the upper 4 bits were not simply redundant sign bits for SW EPP probes and FFT gain scaling may be too high." name="InputFormatterSatErr" offset="1" reset="x" width="1" />
        <field access="ru" desc="Empty packet detected." name="InputFormatterEmptyPktDetect" offset="2" reset="x" width="1" />
        <field access="ru" desc="Symbol framing error and number of data xfer was not mod 512. This is an internal VLSI logic error." name="InputFormatterSymbFrameErr" offset="3" reset="x" width="1" />
        <field access="ru" desc="Format U&lt;9,9&gt;, Subcarrier corresponding ot max *OVER ENTIRE PACKET*." name="NveIntfIdx" offset="4" reset="x" width="9" />
        <field access="ru" desc="Format U&lt;5,5&gt;, Max approx log2 power different of any subcarrier *OVER ENTIRE PACKET*." name="NveIntfMax" offset="13" reset="x" width="5" />
        <field access="ru" desc="Format U&lt;9,9&gt;, Number of subcarriers above intf threshold *IN FINAL SYMBOL*." name="NveIntfCnt" offset="18" reset="x" width="9" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="5" />
      </reg>
    </regfile>
    <regfile desc="PhyFd Tx Bit Loading Table" name="TxBitLoadTable" offset="0x1800" absolute_addr="0xcc155800">
      <mult name="0" num="4" offset="0x100" />
      <reg name="TxBitLoadTable" offset="0x0">
        <field access="rw" desc="The NBits array defines the bitloading and other attributes of the subcarriers comprising an OFDM symbol. See Bit-loading Table Entries for details on the encoding." name="NBits_0" offset="0" reset="x" width="4" />
        <field access="rw" name="NBits_1" offset="4" reset="x" width="4" />
        <field access="rw" name="NBits_2" offset="8" reset="x" width="4" />
        <field access="rw" name="NBits_3" offset="12" reset="x" width="4" />
        <field access="rw" name="NBits_4" offset="16" reset="x" width="4" />
        <field access="rw" name="NBits_5" offset="20" reset="x" width="4" />
        <field access="rw" name="NBits_6" offset="24" reset="x" width="4" />
        <field access="rw" name="NBits_7" offset="28" reset="x" width="4" />
        <mult name="0" num="64" offset="0x4" />
      </reg>
    </regfile>
    <regfile desc="PhyFd Tx Power Load Table" name="TxPowerLoadGain" offset="0x1c00" absolute_addr="0xcc155c00">
      <mult name="0" num="2" offset="0x200" />
      <reg name="TxPowerLoadGain">
        <field access="rw" name="TxPowerLoadGain_3" offset="0" reset="x" width="8" />
        <field access="rw" name="TxPowerLoadGain_2" offset="8" reset="x" width="8" />
        <field access="rw" name="TxPowerLoadGain_1" offset="16" reset="x" width="8" />
        <field access="rw" desc="The TxPowerLoadGain array specifies the additional gain per subcarrier for power loading. Each entry is added to TxPowerLoadGainBase to yield the overall gain applied to the corresponding subcarrier." name="TxPowerLoadGain_0" offset="24" reset="x" width="8" />
        <mult name="0" num="128" offset="0x4" />
      </reg>
    </regfile>
    <regfile desc="PhyFd Tx Channel Estimate Reference Table" name="TxRxChanEstRef" offset="0x2000" absolute_addr="0xcc156000">
      <mult name="0" num="3" offset="0x040" />
      <reg name="TxRxChanEstRef">
        <field access="rw" name="TxRxChanEstRef_3" offset="0" reset="x" width="8" />
        <field access="rw" name="TxRxChanEstRef_2" offset="8" reset="x" width="8" />
        <field access="rw" name="TxRxChanEstRef_1" offset="16" reset="x" width="8" />
        <field access="rw" desc="The ChanEstRef array defines the bit sequence used to generate the channel estimation symbol. Each used (MoCA 1.x) or available (c.LINK+) subcarrier is BPSK modulated according to the corresponding bit in the ChanEstRef array. See Reference Data Order for information on the format." name="TxRxChanEstRef_0" offset="24" reset="x" width="8" />
        <mult name="0" num="16" offset="0x4" />
      </reg>
    </regfile>
    <regfile desc="PhyFd Tx Long Sequence Reference Table" name="TxLongSeqRef" offset="0x20c0" absolute_addr="0xcc1560c0">
      <mult name="0" num="4" offset="0x010" />
      <reg name="TxLongSeqRef">
        <field access="rw" name="TxLongSeqRef_3" offset="0" reset="x" width="8" />
        <field access="rw" name="TxLongSeqRef_2" offset="8" reset="x" width="8" />
        <field access="rw" name="TxLongSeqRef_1" offset="16" reset="x" width="8" />
        <field access="rw" desc="The TxLongSeqRef array defines the bit sequence used to generate the c.LINK+ long-sequence symbol. Every fourth available subcarrier is BPSK modulated according to the corresponding bit in the TxLongSeqRef array. See Reference Data Order for information on the format." name="TxLongSeqRef_0" offset="24" reset="x" width="8" />
        <mult name="0" num="4" offset="0x4" />
      </reg>
    </regfile>
    <regfile desc="PhyFd Rx Bit Loading Table" name="RxBitLoadTable" offset="0x2400" absolute_addr="0xcc156400">
      <mult name="0" num="4" offset="0x100" />
      <reg name="RxBitLoadTable">
        <field access="rw" desc="The NBits array defines the bitloading and other aspects of the subcarriers comprising an OFDM symbol. See Bit-loading Table Entries for details on the encoding." name="NBits_0" offset="0" reset="x" width="4" />
        <field access="rw" name="NBits_1" offset="4" reset="x" width="4" />
        <field access="rw" name="NBits_2" offset="8" reset="x" width="4" />
        <field access="rw" name="NBits_3" offset="12" reset="x" width="4" />
        <field access="rw" name="NBits_4" offset="16" reset="x" width="4" />
        <field access="rw" name="NBits_5" offset="20" reset="x" width="4" />
        <field access="rw" name="NBits_6" offset="24" reset="x" width="4" />
        <field access="rw" name="NBits_7" offset="28" reset="x" width="4" />
        <mult name="0" num="64" offset="0x4" />
      </reg>
    </regfile>
    <regfile desc="PhyFd Rx Bin Deinterleave Table" name="RxBinDeintTable" offset="0x2800" absolute_addr="0xcc156800">
      <mult name="0" num="4" offset="0x100" />
      <reg name="RxBinDeintTable">
        <field access="rw" desc="The ContextID of the corresponding subcarrier. Supported values are 0 through 15." name="ContextID_0" offset="0" reset="x" width="4" />
        <field access="rw" name="ContextID_1" offset="4" reset="x" width="4" />
        <field access="rw" name="ContextID_2" offset="8" reset="x" width="4" />
        <field access="rw" name="ContextID_3" offset="12" reset="x" width="4" />
        <field access="rw" name="ContextID_4" offset="16" reset="x" width="4" />
        <field access="rw" name="ContextID_5" offset="20" reset="x" width="4" />
        <field access="rw" name="ContextID_6" offset="24" reset="x" width="4" />
        <field access="rw" name="ContextID_7" offset="28" reset="x" width="4" />
        <mult name="0" num="64" offset="0x4" />
      </reg>
    </regfile>
    <regfile desc="PhyFd Rx EVM Table" name="RxEvm" offset="0x2c00" absolute_addr="0xcc156c00">
      <mult name="0" num="4" offset="0x200" />
      <reg name="RxEvm">
        <field access="rw" name="Evm_0" offset="0" reset="x" width="8" />
        <field access="rw" name="Evm_1" offset="8" reset="x" width="8" />
        <field access="rw" name="Evm_2" offset="16" reset="x" width="8" />
        <field access="rw" name="Evm_3" offset="24" reset="x" width="8" />
        <mult name="0" num="128" offset="0x4" />
      </reg>
    </regfile>
  </block>
  <block name="PhyDl" offset="0xcc150000">
    <regfile desc="PhyDl Rx Csbuff Status (dynamic status register)" name="RxCsbSts" offset="0x1080" absolute_addr="0xcc151080">
      <mult name="0" num="4" offset="0x100" />
      <reg name="RxDllEntryStatus" offset="0x00">
        <field access="rw" desc="Alias - see TxDllEntryControl register description." name="ControlEmpty" offset="0" reset="1" width="1" />
        <field access="rw" desc="Set to '0' by hardware to indicate the entry has valid status. Writing a '1' indicates the entry is transferred to hardware for reuse." name="Empty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Alias - see RxDllEntryControl register description." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="1" />
        <field access="ru" desc="How does this happen?." name="RxDllControlUnderflow" offset="4" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="RxDllStatusLost" offset="5" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="RxDllStatusOverflow" offset="6" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="25" />
      </reg>
      <reg name="RxDllFecStatus" offset="0x04">
        <field access="ru" desc="0: no error detected by LDPC decoder 1: error detected by LDPC decoder Set to '1' when the LDPC decoder is enabled and an uncorrectable error is detected in at least one codeword in the packet." name="LdpcDecErr" offset="0" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="1" reset="x" width="1" />
        <field access="ru" desc="0: no error detected by R-S decoder 1: error detected by R-S decoder Set to '1' when the Reed-Solomon decoder is enabled and an uncorrectable error is detected in at least one codeword in the packet." name="RsDecErr" offset="2" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="28" />
        <field access="ru" desc="0: one or more uncorrectable errors detected in packet 1: no uncorrectable errors detected in packet Indicates the success of the last enabled FEC unit in the processing chain. Set to '1' when no FEC unit is enabled." name="RxFecSuccess" offset="31" reset="x" width="1" />
      </reg>
      <reg name="RxLdpcDecStatus_0" offset="0x08">
        <field access="ru" name="RESERVED" offset="0" reset="x" width="16" />
        <field access="ru" desc="Number of uncorrectable blocks detected in packet. Saturates at the maximum value. Set to 0 when the LDPC decoder is not enabled." name="NumErrs" offset="16" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="26" reset="x" width="6" />
      </reg>
      <reg name="RxLdpcDecStatus_1" offset="0x0c">
        <field access="ru" desc="Number of times decode aborted by the input buffer filling. This applies to both OFDM and OFDMA." name="LdpcDecNumAbortIters" offset="0" reset="x" width="8" />
        <field access="ru" desc="Number of times decode stopped by reaching iteration limit. This applies to both OFDM and OFDMA." name="LdpcDecNumMaxIters" offset="8" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxLdpcDecStatus_2" offset="0x10">
        <field access="ru" name="NumStopIters_4" offset="0" reset="x" width="8" />
        <field access="ru" name="NumStopIters_5" offset="8" reset="x" width="8" />
        <field access="ru" name="NumStopIters_6" offset="16" reset="x" width="8" />
        <field access="ru" desc="OFDMA codeword 7 number of times decode stopped by stop iteration criteria; Not valid in OFDM mode." name="NumStopIters_7" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RxLdpcDecStatus_3" offset="0x14">
        <field access="ru" desc="For OFDMA codeword 0 or OFDM packet." name="NumStopIters_0" offset="0" reset="x" width="8" />
        <field access="ru" name="NumStopIters_1" offset="8" reset="x" width="8" />
        <field access="ru" name="NumStopIters_2" offset="16" reset="x" width="8" />
        <field access="ru" name="NumStopIters_3" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RxLdpcDecStatus_4" offset="0x18">
        <field access="ru" name="DecMaxDecLayers_4" offset="0" reset="x" width="8" />
        <field access="ru" name="DecMaxDecLayers_5" offset="8" reset="x" width="8" />
        <field access="ru" name="DecMaxDecLayers_6" offset="16" reset="x" width="8" />
        <field access="ru" desc="OFDMA codeword 7 maximum number of layers processed for a codeword; Not valid in OFDM mode." name="DecMaxDecLayers_7" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RxLdpcDecStatus_5" offset="0x1c">
        <field access="ru" desc="For OFDMA codeword 0 or OFDM packet." name="DecMaxDecLayers_0" offset="0" reset="x" width="8" />
        <field access="ru" name="DecMaxDecLayers_1" offset="8" reset="x" width="8" />
        <field access="ru" name="DecMaxDecLayers_2" offset="16" reset="x" width="8" />
        <field access="ru" name="DecMaxDecLayers_3" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RxLdpcDecStatus_6" offset="0x20">
        <field access="ru" name="TotalDecLayers_6" offset="0" reset="x" width="16" />
        <field access="ru" desc="OFDMA codeword 7 cumulative number of layers processed for all codeswords in pack. Not valid in OFDM mode." name="TotalDecLayers_7" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxLdpcDecStatus_7" offset="0x24">
        <field access="ru" name="TotalDecLayers_4" offset="0" reset="x" width="16" />
        <field access="ru" name="TotalDecLayers_5" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxLdpcDecStatus_8" offset="0x28">
        <field access="ru" name="TotalDecLayers_2" offset="0" reset="x" width="16" />
        <field access="ru" name="TotalDecLayers_3" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxLdpcDecStatus_9" offset="0x2c">
        <field access="ru" desc="For OFDMA codeword 0 or OFDM packet." name="TotalDecLayers_0" offset="0" reset="x" width="16" />
        <field access="ru" name="TotalDecLayers_1" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RxRsDecStatus" offset="0x30">
        <field access="ru" desc="Number of bytes corrected in packet. Set to 0 when the R-S decoder is not enabled." name="NumCorrections" offset="0" reset="x" width="11" />
        <field access="ru" name="RESERVED" offset="11" reset="x" width="5" />
        <field access="ru" desc="Number of uncorrectable blocks detected in packet. Set to 0 when the R-S decoder is not enabled." name="NumErrs" offset="16" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RxDllStatus" offset="0x34">
        <field access="ru" desc="Short block if insufficient data to complete last block." name="ByteDeinterleaverShortBlock" offset="0" reset="x" width="1" />
        <field access="ru" name="RESERVED" offset="1" reset="x" width="31" />
      </reg>
    </regfile>
    <regfile desc="PhyDl Tx Ldpc (Encode) Parity Matrix Table Registers" name="TxLdpcEnc" offset="0x100" absolute_addr="0xcc150100">
      <reg name="ConfigControl" offset="0x0">
        <field access="rw" desc="0: 4608 rate 19/24 ... 1: 576 rate 3/4 ... Specifies the generator matrix accessed by writes and reads to TxLdpcEncConfigData." name="CodeSel" offset="24" reset="x" width="1" />
        <field access="rw" desc="When '0' and set to '1' the internal configuration address counters are set to (0,0). The next write or read to TxLdpcEncConfigData accesses address (0,0)." name="SetStartAddr" offset="28" reset="x" width="1" />
      </reg>
      <reg name="ConfigData" offset="0x4">
        <field access="rw" desc="Accesses to this register write or read the generator matrix of the code selected by CodeSel. The 4608 code uses a 38x960 submatrix and the 576 code uses a 36x144 submatrix. Sequential accesses to this register access the selected submatrix in row-major order with the internal address counters incremented after each access. See XXX for details of the format." name="Data" offset="0" reset="x" width="32" />
      </reg>
    </regfile>
    <regfile desc="PhyDl Rx Ldpc (Decode) Parity Matrix Table Registers" name="RxLdpcDec" offset="0x500" absolute_addr="0xcc150500">
      <reg name="ConfigControl" offset="0x0">
        <field access="rw" desc="0: 4608 rate 19/24 ... 1: 576 rate 3/4 ... Specifies the generator matrix accessed by writes and reads to TxLdpcEncConfigData." name="CodeSel" offset="24" reset="x" width="2" />
        <field access="rw" desc="When '0' and set to '1' the internal configuration address counters are set to (0,0). The next write or read to TxLdpcEncConfigData accesses address (0,0)." name="SetStartAddr" offset="28" reset="x" width="1" />
      </reg>
      <reg name="ConfigData" offset="0x4">
        <field access="rw" desc="Accesses to this register write or read the generator matrix of the code selected by CodeSel. The 4608 code uses a 38x960 submatrix and the 576 code uses a 36x144 submatrix. Sequential accesses to this register access the selected submatrix in row-major order with the internal address counters incremented after each access. See XXX for details of the format." name="Data" offset="0" reset="x" width="32" />
      </reg>
    </regfile>
  </block>
  <block name="RFIC Interface" offset="0xcc15e000">
    <regfile desc="RFIC Direct Interface Registers" name="Csr" offset="0">
      <reg name="RFIC_Address" offset="0x000">
        <field access="rw" name="Run" offset="0" reset="0" width="1" name_color="r" />
        <field access="rw" name="Address" offset="1" reset="x" width="3" name_color="r" />
        <field access="rw" name="Mode" offset="4" reset="x" width="1" name_color="r" />
        <field access="rw" name="NumAddr" offset="5" reset="x" width="4" name_color="r" />
        <field access="ru" name="RESERVED" offset="9" reset="x" width="1" />
        <field access="rw" name="NumData" offset="10" reset="x" width="6" name_color="r" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RFIC_DataHigh" offset="0x008">
        <field access="rw" name="Data_54_32" offset="0" reset="x" width="23" name_color="r" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="9" />
      </reg>
      <reg name="RFIC_DataLow" offset="0x00c">
        <field access="rw" name="Data_31_0" offset="0" reset="x" width="32" name_color="r" />
      </reg>
    </regfile>
  </block>
  <block name="PhyRfic" offset="0xcc15c000">
    <regfile desc="PhyRf Csr (static control register)" name="Csr" offset="0">
      <reg name="PhyRficCtrl" offset="0x004">
        <field access="rw" desc="0: TRfic reset 1: Rfic enabled." name="Enable" offset="0" reset="0" width="1" />
        <field access="rw" desc="0: &quot;circular queue&quot; mode 1: &quot;register&quot; mode ... Normal operation uses &quot;circular queue&quot; mode. Repetitive and continuous operation use &quot;register&quot; mode." name="DynCtrlMode" offset="1" reset="x" width="1" />
        <field access="ru" desc="Revision number of module." name="Revision" offset="2" reset="0" width="8" />
        <field access="ru" desc="Indicates module type. PHY = TBS." name="ModuleID" offset="10" reset="0" width="16" />
        <field access="rw" desc="special status mode ." name="DynStatusMode" offset="26" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="27" reset="x" width="5" />
      </reg>
      <reg name="RficCtrl_0" offset="0x008" width="1">
        <field access="rw" desc="Front-end fixed current control bits ... &lt;00&gt;=25uA ... &lt;01&gt;=37.5uA ... &lt;10&gt;=50uA... &lt;11&gt;=62.5uA " name="RxAfeIvga" offset="0" reset="10" width="2"></field>
        <field access="rw" desc="Controls the AAF cut-off frequency" name="RxAfeFtuneIn" offset="2" reset="10000" width="5"></field>
        <field access="rw" desc="ADC fixed current control bits. ... 00 25uA ... 01 37.5uA ... 10 50uA ... 11 62.5uA" name="RxAfeIadc" offset="7" reset="10" width="2"></field>
        <field access="rw" desc="Enable digital loopback from ADC output to DAC input. In this mode, the DAC clock is switched to the 160MHz ADC Clock." name="RxAfeEnAdcDacLpbk" offset="9" reset="0" width="1"></field>
        <field access="rw" desc="3 bits controlling the loopbacks paths inside the Receiver I Channel: (All loopbacks should be considered exclusive) lpbk_rxicntl&lt;0&gt; &#x2018;0&#x2019;: High RF Mode: no loopbacks, High RF inputs can be forced through the pads. &#x2018;1&#x2019;: High RF inputs forced through loopback from the Q Channel test Amplifier outputs. 010: I Channel VGA outputs loopback enabled to the Q Channel Test Amplifier Inputs. 100: I Channel RX Inputs loopback enabled to the I Channel Test Amplifier Inputs. " name="RxAfeLpbkRxicntl" offset="10" reset="0" width="3"></field>
        <field access="rw" desc="3 bits controlling the loopbacks paths inside the Receiver Q Channel: (All loopbacks should be considered exclusive) lpbk_rxqcntl&lt;0&gt; &#x2018;0&#x2019;: High RF Mode: no loopbacks, High RF inputs can be forced through the pads. &#x2018;1&#x2019;: High RF inputs forced through loopback from the I Channel Test Amplifier outputs. 010: Q Channel VGA outputs loopback enabled to the I Channel Test Amplifier Inputs. 100: Q Channel RX inputs loopback enabled to the Q Channel Test Amplifier Inputs. " name="RxAfeLpbkRxqcntl" offset="13" reset="0" width="3"></field>
        <field access="rw" desc="Powers down ADC References when =0" name="RxAfeEnAdcRef" offset="16" reset="0" width="1"></field>
        <field access="rw" desc="Powers down ADC Regulator when =0" name="RxAfeEnAdcReg" offset="17" reset="0" width="1"></field>
        <field access="rw" desc="2 bits to control the non-overlap clocks of the ADC clock generator." name="RxAfeAdcNoverCntl" offset="18" reset="11" width="2"></field>
        <field access="rw" desc="3 bits controlling the DC Mux selection. Selected Voltage to be sent to the caladc output pad 000: DC Test Mux in HiZ 001: caladc_in 010: vtunedc 011: vrefp 100: vagnd 101: vrefm 110: vporh 111: vporl " name="RxAfeDcMuxSel" offset="20" reset="0" width="3"></field>
        <field access="rw" desc="AAF BW selection bit 0: Moca 1 configuration 1: Moca 2 configuration " name="RxAfeBwsel" offset="23" reset="1" width="1"></field>
        <field access="rw" desc="0: 80MHz (for Moca1 configuration) 1: 160MHz (for Moca2 configuration)" name="AdcClksel" offset="24" reset="1" width="1"></field>
        <field access="rw" desc="Powers down I Channel Test Amplifier. &#x2018;1&#x2019; enable, &#x2018;0&#x2019; power down. It puts the Test Amplifier Output in HiZ mode." name="TxAfeEnTai" offset="25" reset="0" width="1"></field>
        <field access="rw" desc="Powers down Q Channel Test Amplifier. &#x2018;1&#x2019; enable, &#x2018;0&#x2019; power down. It puts the Test Amplifier Output in HiZ mode." name="TxAfeEnTaq" offset="26" reset="0" width="1"></field>
        <field access="rw" desc="TBD." name="RxAfeEnTuning" offset="27" reset="x" width="1"></field>
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RficCtrl_1" offset="0x00c">
        <field access="rw" desc="Test Amplifiers I&amp;Q fixed current control bits. &lt;00&gt;=25uA &lt;01&gt;=37.5uA &lt;10&gt;=50uA &lt;11&gt;=62.5uA " name="TxAfeIta" offset="0" reset="10" width="2"></field>
        <field access="rw" desc="1 bit controlling the loopback path from the TX I channel side to the RX I channel side: 0: no loopback 1: I Channel Test Amplifier loopback enabled" name="TxAfeLpbkTxiRxiCntl" offset="2" reset="0" width="1"></field>
        <field access="rw" desc="2 bits controlling the analog multiplexer at the input of the line driver: 00: reference voltage selected. 01: I Channel RX Inputs selected 10: Q Channel VGA outputs selected 11: I Channel Test Amplifier to Q Channel Test Amplifier Calibration Loopback. " name="TxAfeLpbkTxicntl" offset="3" reset="0" width="2"></field>
        <field access="rw" desc="1 bit controlling the direction of the pads ta_outp_i/ta_outm_i: 0: ta_outp_i/ta_outm_i are outputs of the Test Amplifier. 1: ta_outp_i/ta_outm_i are inputs and could be used to feed signals through the test amplifier input analog multiplexer controlled by lpbk_txicntl&lt;1:0&gt; to its inputs. " name="TxAfeLpbkTxicntl_2" offset="5" reset="x" width="1"></field>
        <field access="rw" desc="1 bit controlling the loopback path from the TX Q channel side to the RX Q channel side: 0: no loopback 1: Q Channel Test Amplifier loopback enabled " name="TxAfeLpbkTxqRxqCntl" offset="6" reset="0" width="1"></field>
        <field access="rw" desc="2 bits controlling the analog multiplexer at the input of the test amplifier: 00: reference voltage selected. 01: Q Channel RX inputs selected 10: I Channel VGA outputs selected 11: I Channel Test Amplifier to Q Channel Test Amplifier Calibration Loopback." name="TxAfeLpbkTxqcntl" offset="7" reset="x" width="2"></field>
        <field access="rw" desc="1 bit controlling the direction of the pads ta_outp_q/ta_outm_q: 0: ta_outp_q/ta_outm_q are outputs of the test amplifier. 1: ta_outp_q/ta_outm_q are inputs and could be used to feed signals through the test amplifier input analog multiplexer controlled by lpbk_txqcntl&lt;1:0&gt; to its inputs. " name="TxAfeLpbkTxqcntl_2" offset="9" reset="0" width="1"></field>
        <field access="ru" name="RESERVED" offset="10" reset="x" width="22" />
      </reg>
      <reg name="RficCtrl_2" offset="0x0010">
        <field access="rw" desc="Select cal adc input source. Refer to AFE document for specific select values. Field may be written at the same time that CalAdcEn field is written to 1." name="CalAdcSel" offset="0" reset="001" width="3"></field>
        <field access="rw" desc="Desired cal adc measure count: number of cal cycles to accumulate measurements over, 1-&gt;255, 0=continuous conversions which never asserts sts_done_pulse to shut down cal adc logic" name="CalAdcMeasCnt" offset="3" reset="0" width="8"></field>
        <field access="rw" desc="Enable cal adc references in AFE. Must be asserted 1 millisecond prior to CalAdcEn assertion" name="CalAdcRefEn" offset="11" reset="0" width="1"></field>
        <field access="rw" desc="Enable cal adc digital and AFE circuits. When 0, cal adc is held in reset, cal adc clocks are gated off, and RficCalAdcSta status registers are also reset. Writing a 0, followed by writing a 1 starts cal cycles" name="CalAdcEn" offset="12" reset="x" width="1"></field>
        <field access="ru" name="RESERVED" offset="13" reset="x" width="19" />
      </reg>
      <reg name="RficFreq_0" offset="0x014">
        <field access="rw" desc="SPAR: Bits 47:32 of freq_word_0" name="FreqWord_0Upper" offset="0" reset="0" width="16"></field>
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RficFreq_1" offset="0x018">
        <field access="rw" desc="Bits 31:0 of freq_word_0." name="FreqWord_0Lower" offset="0" reset="0" width="32"></field>
      </reg>
      <reg name="RficFreq_2" offset="0x01c">
        <field access="rw" desc="SPAR: Bits 47:32 of freq_word_1" name="FreqWord_1Upper" offset="0" reset="0" width="16"></field>
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
      <reg name="RficFreq_3" offset="0x020">
        <field access="rw" desc="Bits 31:0 of freq_word_1." name="FreqWord_1Lower" offset="0" reset="0" width="32"></field>
      </reg>
      <reg name="RficDesc_0" offset="0x024">
        <field access="rw" desc="the window before pre load time in which descriptors should be ready  and processed" name="DescInvalidPreWin" offset="0" reset="0" width="32"></field>
      </reg>
      <reg name="RficDesc_1" offset="0x0028">
        <field access="rw" desc="the window after pre load time in which descriptors will still be processed" name="DescInvalidPostWin" offset="0" reset="0" width="11" />
        <field access="rw" desc="If no Tx transmission occurs during the period from TimeToProcess to TimeTo_process + TxActiveWin the status NoTxDataErr is asserted." name="TxActiveValidWin" offset="11" reset="0" width="11"></field>
        <field access="ru" name="RESERVED" offset="22" reset="x" width="10" />
      </reg>
      <reg name="RficDesc_2" offset="0x002c">
        <field access="rw" desc="Override enables for en_adci, en_adcq, en_dcblk, en_vgai, en_vgaq, hp_pole, en_daci, en_dacq (correspondingly)" name="AfeDescOverriedsEn" offset="0" reset="0" width="8" />
        <field access="rw" desc="Override values for en_adci, en_adcq, en_dcblk,  en_vgai, en_vgaq, hp_pole[1:0], en_daci, en_dacq (correspondingly)" name="AfeDescOverrieds" offset="8" reset="0" width="9"></field>
        <field access="rw" desc="when high fast agc messages are not sent" name="FastAgcDis" offset="17" reset="0" width="1"></field>
        <field access="rw" desc="when high clears latched static statuses" name="DescStatusClr" offset="18" reset="x" width="1"></field>
        <field access="ru" name="RESERVED" offset="19" reset="x" width="13" />
      </reg>
      <reg name="RficCtrls_0" offset="0x0030">
        <field access="rw" desc="TX DAC Speed Control: 0: 200MHz 1: 400MHz " name="TxAfeDacSpeed400Cntl" offset="0" reset="1" width="1" />
        <field access="rw" desc="if high, packet end time occurs in time_to_process _ packet_length otherwise detected using PHY_TD signals" name="SwPacketEndMode" offset="1" reset="0" width="1" />
        <field access="rw" desc="Expansion mode for pre-packet Eldora message length. if high, send 18 bits length (bits 17:16 are prepkt_exp[1:0]) otherwise send 16 bits" name="PrePktExpMode" offset="2" reset="0" width="1" />
        <field access="rw" desc="if high dummy_packet DPAR is enabled" name="EnDummyPacket" offset="3" reset="0" width="1" />
        <field access="rw" desc="When '0' (default) tx_packet_end occure in time_to_process_packet_length. When '1' occurs on TD_TX packet end." name="TxPacketEndCya" offset="4" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="5" reset="x" width="27" />
      </reg>
      <reg name="RficCtrls_1" offset="0x034">
        <field access="rw" desc="LSB's for indirect message to Eldora" name="RficDataLow" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RficCtrls_2" offset="0x038">
        <field access="rw" desc="MSB's for indirect message to Eldora" name="RficDataHigh" offset="0" reset="0" width="16"></field>
        <field access="rw" desc="If high issues Eldora message. SW should de-assert when done" name="RficIndirectRun" offset="16" reset="x" width="1"></field>
        <field access="rw" desc="Specify the Eldora's message type: '100' for pre-packet, '110' for fast AGC, '111' for fast TX/Rx, '011' for indirect message" name="RficIndirectAddr" offset="17" reset="0" width="3"></field>
        <field access="rw" desc="0 for indirect messages read, 1 for indirect messages write" name="RficIndirectRdWr" offset="20" reset="x" width="1"></field>
        <field access="ru" name="RESERVED" offset="21" reset="x" width="12" />
      </reg>
      <reg name="RficCtrls_3" offset="0x03c">
        <field access="rw" desc="1: repeat mode enable. 0: repeat mode disable" name="RepeatModeEn" offset="0" reset="0" width="1"></field>
        <field access="rw" desc="if high HW uses TD_TX packet end otherwise TD_RX packet end" name="TxRepeatMode" offset="1" reset="0" width="1"></field>
        <field access="rw" desc="In repeat mode, the time between packet end to new packet start" name="RepeatDly" offset="2" reset="x" width="16"></field>
        <field access="ru" name="RESERVED" offset="18" reset="x" width="14" />
      </reg>
      <reg name="RficCtrls_4" offset="0x040">
        <field access="rw" desc="5 Spare bits that can be WRITTEN into the AFE from the SOC section. " name="AfeWrSpare" offset="0" reset="0" width="5"></field>
        <field access="rw" desc="afe test mode uses register settings (instead of forced values" name="AfeModeUsesRegs" offset="5" reset="0" width="1"></field>
        <field access="rw" desc="enable SIO write transactions" name="SioWrEn" offset="6" reset="0" width="1"></field>
        <field access="rw" desc=" GPIO[3:0]==phy_rfic_gpio_ovrd_value[3:0] in case phy_rfic_gpio_ovrd_en[3:0]==1 correspondingly" name="PhyRficGpioOvrdValue" offset="7" reset="0" width="4"></field>
        <field access="rw" desc="for each gpio, select phy_rfic gpio (1) or system resource GPIO (0)" name="PhyRficGpioSel" offset="11" reset="0" width="4"></field>
        <field access="rw" desc="if high, override dynamic GPIO[3:0] with phy_rfic_gpio_ovrd_value[3:0]" name="PhyRficGpioOvrdEn" offset="15" reset="0" width="4"></field>
        <field access="rw" desc="sio_reset" name="EldoraReset" offset="19" reset="0" width="1"></field>
        <field access="ru" name="RESERVED" offset="20" reset="x" width="12" />
      </reg>
    </regfile>
  </block>
  <block name="PhyRfic" offset="0xcc15c000">
    <regfile desc="PhyRfic Csr Status (static status register)" name="Csr" offset="0x0400" absolute_addr="0xcc15c400">
      <reg name="RficStaticStatus_0">
        <field access="ru" desc="the rfic descriptors state machine" name="RficDescFsm" offset="0" reset="x" width="3" />
        <field access="ru" desc="number of bad/discarded RFIC packets count - wrap" name="BadPcktsCnt" offset="3" reset="x" width="4" />
        <field access="ru" desc="number of pre messages sent count - wrap" name="PreMsgCnt" offset="7" reset="x" width="4" />
        <field access="ru" desc="number of TX/RX power messages sent count - wrap" name="TxRxPwrMsgCnt" offset="11" reset="x" width="4" />
        <field access="ru" desc="number of total AGC messages sent count including inits and fast - wrap" name="AgcMsgCnt" offset="15" reset="x" width="8" />
        <field access="ru" name="RESERVED" offset="23" reset="x" width="9" />
      </reg>
      <reg name="RficStatus_1">
        <field access="ru" desc="Total accumulated sum (unsigned 16b) of cal_data over the currently completed CalAdcStsAccmCnt number of cal cycles. Field will continue to update each cal cycle along with CalAdcStsAccmCnt until CalAdcMeasCnt cycles have been reached. In continuous mode, this register continuously updates and represents each sample instead of an accumulated value." name="CalAdcStsAccm" offset="0" reset="x" width="16" />
        <field access="ru" desc="Number of cal cycles currently completed and accumulated over, 0-&gt;255. Field will continue to update each cal cycle along with CalAdcStsAccm until CalAdcMeasCnt cycles have been reached. Use this field to confirm that all cal adc cycles are done. In continuous mode, cycles will run continuously and this count will be 1 for every cycle completed." name="CalAdcStsAccmCnt" offset="16" reset="x" width="8" />
        <field access="ru" desc=" 5 Spare bits that can be READ from the AFE by the SOC" name="AfeRSpare" offset="24" reset="1" width="5"></field>
        <field access="ru" name="RESERVED" offset="29" reset="x" width="2" />
        <field access="ru" desc="Asserted when any status is ready after each cal cycle. Does not indicate all cycles are done since status continues to update until CalAdcMeasCnt number of cal cycles have completed." name="CalAdcStsRdy" offset="31" reset="x" width="1" />
      </reg>
      <reg name="RficStatus_2">
        <field access="ru" desc="High when indirect read transaction finished. Cleared when DescStatusClr high " name="RficDataReadRdy" offset="0" reset="1" width="1" />
        <field access="ru" desc="TBD " name="SioBusy" offset="1" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="2" reset="x" width="30" />
      </reg>
      <reg name="RficStatus_3">
        <field access="ru" desc="indirect read from Eldora" name="RficDataRead" offset="0" reset="1" width="32" />
      </reg>
    </regfile>
  </block>
  <block name="PhyRfic" offset="0xcc15c000">
    <regfile desc="PhyRfic csbuff (dynamic control register)" name="CsbCtl" offset="0x0800" absolute_addr="0xcc15c800">
      <mult name="0" num="8" offset="0x100" />
      <reg name="RfEntryControl" offset="0x00">
        <field access="rw" desc="Writing a '0' transfers this entry to hardware for processing. Writing a '1' transfers this entry to software for reuse." name="Empty" offset="0" reset="1" width="1" />
        <field access="ru" desc="State of corresponding status entry - see TxEntryNStatus register description." name="StatusEmpty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Indicates this entry has been processed (but status not necessarily available). 0: not processed 1: processed." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="1" />
        <field access="ru" name="ControlUnderflow" offset="4" reset="0" width="1" />
        <field access="ru" name="Lost" offset="5" reset="0" width="1"></field>
        <field access="ru" name="Overflow" offset="6" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="25" />
      </reg>
      <reg name="RficDctrl_0" offset="0x04">
        <field access="rw" desc="reference CTC time for various actions" name="TimeToProcess" offset="0" reset="x" width="32" />
      </reg>
      <reg name="RficDctrl_1" offset="0x08">
        <field access="rw" desc="Packet lengtn.If sw_packet_end_mode=1, specifies the time from time_to_process in which SW packet end is occurs. In HW packet mode, specifies the maximum time from time_to_process in which RX packet should end. " name="PacketLength" offset="0" reset="x" width="20"></field>
        <field access="ru" name="RESERVED" offset="20" reset="x" width="12" />
      </reg>
      <reg name="RficDctrl_2" offset="0x0c">
        <field access="rw" desc="time prior to time_to_process for sending Prepacket message to RFIC" name="PrepktPreOffset" offset="0" reset="x" width="12" />
        <field access="rw" desc="time prior to time_to_process to send prior-to-packet Fast Power message" name="FpPreOffset" offset="12" reset="x" width="12"></field>
        <field access="ru" name="RESERVED" offset="24" reset="x" width="8" />
      </reg>
      <reg name="RficDctrl_3" offset="0x010">
        <field access="rw" desc="delay after packet_end for sending post-packet Fast Power message to RFIC " name="FpPostOffset" offset="0" reset="x" width="10" />
        <field access="rw" desc="time prior to time_to_process for sending Indirect frequency message to RFIC" name="HopPreOffset" offset="10" reset="x" width="12" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="10" />
      </reg>
      <reg name="RficDctrl_4" offset="0x014">
        <field access="rw" desc="time prior to time_to_process for changing gpio[3:0] to rf_gpio_pre_value[3:0]" name="RfGpioPreOffset" offset="0" reset="x" width="12"></field>
        <field access="rw" desc="delay after packet_end for changing gpio[3:0] to rf_gpio_post_value[3:0]" name="RfGpioPostOffset" offset="12" reset="x" width="10" />
        <field access="ru" name="RESERVED" offset="22" reset="x" width="10" />
      </reg>
      <reg name="RficDctrl_5" offset="0x018">
        <field access="rw" desc="time prior to time_to_process for enabling En_dac_i, en_dac_q" name="AfeTxPreOffset" offset="0" reset="x" width="12"></field>
        <field access="rw" desc="delay after packet_end for disabling En_dac_i, en_dac_q" name="AfeTxPostOffset" offset="12" reset="x" width="10"></field>
        <field access="ru" name="RESERVED" offset="22" reset="x" width="10" />
      </reg>
      <reg name="RficDctrl_6" offset="0x01c">
        <field access="rw" desc="time prior to time_to_process for enabling En_adc_i, en_adc_q, En_vga_i, en_vga_q and for updating En_dcblk, En_tuning, afe_hp_pole[1:0]" name="AfeRxPreOffset" offset="0" reset="x" width="12"></field>
        <field access="rw" desc="delay after packet_end for disabling En_adc_i, en_adc_q, En_vga_i, en_vga_q" name="AfeRxPostOffset" offset="12" reset="x" width="10"></field>
        <field access="ru" name="RESERVED" offset="22" reset="x" width="10" />
      </reg>
      <reg name="RficDctrl_7" offset="0x020">
        <field access="rw" desc="enable/disable Prepacket message" name="EnPrepktPreOffset" offset="0" reset="x" width="1"></field>
        <field access="rw" desc="enable/disable prior-to-packet Fast Power message" name="EnFpPreOffset" offset="1" reset="x" width="1"></field>
        <field access="rw" desc="enable/disable post-packet Fast Power message" name="EnFpPostOffset" offset="2" reset="x" width="1"></field>
        <field access="rw" desc="enable/disable post-packet Fast Power message" name="EnHopPreOffset" offset="3" reset="x" width="1"></field>
        <field access="ru" name="RESERVED" offset="4" reset="x" width="28" />
      </reg>
      <reg name="RficDctrl_8" offset="0x024">
        <field access="rw" desc="When 0: preserve the previous values of en_daci and en_dacq&#xD;&#xA;When 1:  en_daci and en_dacq asserted at afe_tx_pre_offset time only&#xD;&#xA;When 2:  en_daci and en_dacq de-asserted at afe_tx_pre_offset time only&#xD;&#xA;When 3: en_daci and en_dacq asserted at afe_tx_pre_offset time and de-asserted at afe_tx_post_offset time. &#xD;&#xA;" name="AfeTxEnDacMode" offset="0" reset="x" width="2"></field>
        <field access="rw" desc="When 0: preserve the previous values of En_adc_i, en_adc_q, En_vga_i, en_vga_q&#xD;&#xA;When 1:  En_adc_i, en_adc_q, En_vga_i, en_vga_q asserted at afe_rx_pre_offset time only&#xD;&#xA;When 2:  En_adc_i, en_adc_q, En_vga_i, en_vga_q de-asserted at afe_rx_pre_offset time only&#xD;&#xA;When 3:  En_adc_i, en_adc_q, En_vga_i, en_vga_q asserted at afe_rx_pre_offset time and de-asserted at afe_rx_post_offset time. &#xD;&#xA;" name="AfeRxEnAdcVgaMode" offset="2" reset="x" width="2"></field>
        <field access="rw" desc="When 0: preserve the previous value of en_dcblk&#xD;&#xA;When 1: en_dcblk loaded with afe_en_dcblk (descriptor parameter) at afe_rx_pre_offset time. &#xD;&#xA;" name="AfeEnDcblkMode" offset="4" reset="x" width="1"></field>
        <field access="ru" name="RESERVED" offset="5" reset="x" width="1"></field>
        <field access="rw" desc="When 0: preserve the previous value of hp_pole[1:0]&#xD;&#xA;When 1: hp_pole[1:0] loaded with  Afe_hp_pole[1:0] (descriptor parameter) at afe_rx_pre_offset time.&#xD;&#xA;" name="AfeHpPoleMode" offset="6" reset="x" width="1"></field>
        <field access="rw" desc="When 0: preserve the previous value of vga[3:0]&#xD;&#xA;When 1: vga[3:0] loaded with  prepkt_pre_vga[3:0]  (descriptor parameter) at afe_rx_pre_offset time if gain_from_table=0 or with gain table output if gain_from_table=1&#xD;&#xA;" name="AfeVgaMode" offset="7" reset="x" width="1"></field>
        <field access="rw" desc="Value to load into the AFE signal en_dcblk if Afe_en_dcblk_mode=1" name="AfeEnDcblk" offset="8" reset="x" width="1"></field>
        <field access="ru" name="RESERVED" offset="9" reset="x" width="1"></field>
        <field access="rw" desc="Value to load into the AFE signal hp_pole[1:0] if afe_hp_pole_mode=1" name="AfeHpPole" offset="10" reset="x" width="2"></field>
        <field access="ru" name="RESERVED" offset="12" reset="x" width="20" />
      </reg>
      <reg name="RficDctrl_9" offset="0x028">
        <field access="rw" desc="drop into bits [17:16] of Prepacket message if in prepacket message expansion mode, otherwise ignore" name="PrepktSpare" offset="0" reset="x" width="2"></field>
        <field access="rw" desc="drop into bits [15:12] of Prepacket message" name="TxGain" offset="2" reset="x" width="4"></field>
        <field access="rw" desc="drops into bit [11] of Prepacket message" name="BwSelDynam" offset="6" reset="x" width="1"></field>
        <field access="rw" desc="rops into bit [10] of Prepacket message" name="XoPullDynam" offset="7" reset="x" width="1"></field>
        <field access="rw" desc="drop into bits [9:5] of Prepacket message only if CSR gain_from_table=0, otherwise these bits not used and output of loggain table fills Prepacket[9:5]" name="RxRfg" offset="8" reset="x" width="5"></field>
        <field access="rw" desc="drop into bits [4:0] of Prepacket message" name="PktMode" offset="13" reset="x" width="5"></field>
        <field access="rw" desc="drop into prior-to-packet Fast Power message " name="FpPreValue" offset="18" reset="x" width="5"></field>
        <field access="rw" desc="drop post-packet Fast Power message" name="FpPostValue" offset="23" reset="x" width="5"></field>
        <field access="ru" name="RESERVED" offset="28" reset="x" width="4" />
      </reg>
      <reg name="RficDctrl_10" offset="0x02c">
        <field access="rw" desc="loggain table input in case gain_from_table=1. the output of loggain table fills Prepacket[9:5]" name="PrepktPreLogGain" offset="0" reset="x" width="7"></field>
        <field access="rw" desc="the VGA (init) value in pre message time only if gain_from_table=0, otherwise these bits not used and output of loggain go to VGA" name="PrepktPreVga" offset="7" reset="x" width="4"></field>
        <field access="rw" desc="value to set rf_gpio[3:0] to prior to the packet" name="RfGpioPreValue" offset="11" reset="x" width="4"></field>
        <field access="rw" desc="value to set rf_gpio[3:0] to after the packet" name="RfGpioPostValue" offset="15" reset="x" width="4"></field>
        <field access="rw" desc="if hign, the gain fields inside pre load messages comes from the gain table (input to the table comes from pre_pckt_data)" name="GainFromTable" offset="19" reset="x" width="1"></field>
        <field access="rw" desc="In freq_hop message: 0 = send freq_word_0   1 = send freq_word_1 " name="FreqHopWord_0_1" offset="20" reset="x" width="1"></field>
        <field access="rw" desc="0 for normal TX/RX packet, 1 for packet without TD_TX/RX activity but schedule messages are optional" name="DummyPacket" offset="21" reset="x" width="2"></field>
        <field access="ru" name="RESERVED" offset="23" reset="x" width="9" />
      </reg>
      <reg name="RficDctrl_11" offset="0x030">
        <field access="rw" desc="" name="Timetoprocessvalidwindowsize" offset="0" reset="x" width="31"></field>
        <field access="ru" name="RESERVED" offset="31" reset="x" width="1" />
      </reg>
    </regfile>
  </block>
  <block name="PhyRfic" offset="0xcc15c000">
    <regfile desc="PhyRfic Csbuff Status (dynamic status register)" name="CsbSts" offset="0x0880" absolute_addr="0xcc15c880">
      <mult name="0" num="8" offset="0x100"></mult>
      <reg name="RficEntryStatus" offset="0x00">
        <field access="rw" desc="Alias - see TxFdEntryControl register description." name="ControlEmpty" offset="0" reset="1" width="1" />
        <field access="rw" desc="Set to '0' by hardware to indicate the entry has valid status. Writing a '1' indicates the entry is transferred to hardware for reuse." name="Empty" offset="1" reset="1" width="1" />
        <field access="ru" desc="Alias - see TxFdEntryControl register description." name="Processed" offset="2" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="3" reset="x" width="1" />
        <field access="ru" desc="How does this happen?." name="ControlUnderflow" offset="4" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="Lost" offset="5" reset="0" width="1" />
        <field access="ru" desc="How does this happen?." name="Overflow" offset="6" reset="0" width="1" />
        <field access="ru" name="RESERVED" offset="7" reset="x" width="25" />
      </reg>
      <reg name="RficAfeStatus_1" offset="0x04">
        <field access="ru" desc="1  bad timetoprocess&#xD;&#xA;" name="TimeToProcessInvalid" offset="0" reset="1" width="1"></field>
        <field access="ru" desc="number of fast agc messages sent in the corresponded packet" name="FastAgcInPktCnt" offset="1" reset="1" width="3" />
        <field access="ru" desc="high if descriptors flushed due to bad arriving time" name="DescDumpErr" offset="4" reset="1" width="1" />
        <field access="ru" desc=" high if descriptors out of ctc_invalid_win, low if descriptors out of start_window" name="DescDumpType" offset="5" reset="1" width="1" />
        <field access="ru" desc=" high if descriptors flushed due to no TX activity event" name="NoTxDataErr" offset="6" reset="1" width="1" />
        <field access="ru" desc="high if tx packet was identified and processed" name="TxPktProcessed" offset="7" reset="1" width="1" />
        <field access="ru" desc="high if rx packet was identified and processed" name="RxPktProcessed" offset="8" reset="1" width="1" />
        <field access="ru" desc="the last sent log_gain. if all ones means that gain was initialized from table only without fast updates" name="LastLogGain" offset="9" reset="1" width="7" />
        <field access="ru" name="RESERVED" offset="16" reset="x" width="16" />
      </reg>
    </regfile>
    <regfile desc="PhyRfic LogGain Table" name="AnalogGain" offset="0x1800" absolute_addr="0xcc15d800">
      <mult name="0" num="1" offset="0x0" />
      <reg name="LogGain" offset="0x0">
        <field access="rw" name="rx_rfg" desc="RFIC Rx_Rfg field sent through the SIO during FastAGC message" offset="0" reset="x" width="5" />
        <field access="rw" name="VGA" desc="AFE VGA gain parameters for FastAGC message" offset="5" reset="x" width="4" />
        <mult name="0" num="128" offset="0x4" />
      </reg>
    </regfile>
    <!--
    <regfile desc="PhyRfic Back End Gain Table" name="BeGain" offset="0x1a00" absolute_addr="0xcc15da00">
      <mult name="0" num="1" offset="0x0" />
      <reg name="BeGain" offset="0x0">
        <field access="rw" name="Vga2Gain" offset="0" reset="x" width="4" />
        <field access="rw" name="RfVgaGain" offset="4" reset="x" width="3" />
        <mult name="0" num="32" offset="0x4" />
      </reg>
    </regfile>
    <regfile desc="PhyRf Front End Gain Table" name="FeGain" offset="0x1a80" absolute_addr="0xcc15da80">
      <mult name="0" num="1" offset="0x0" />
      <reg name="FeGain" offset="0x0">
        <field access="rw" name="LnaGs" offset="0" reset="x" width="3" />
        <field access="rw" name="SwAtc" offset="3" reset="x" width="2" />
        <mult name="0" num="8" offset="0x4" />
      </reg>
    </regfile>
-->
  </block>
</system>